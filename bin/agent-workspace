#!/usr/bin/env -S zsh -f
# Generated from: graysurf/zsh-kit@dcf65f9600c24b87d14bf506d017996a70a32103
# DO NOT EDIT: regenerate via scripts/generate_agent_workspace_bundle.sh
set -e

# Bundled from: scripts/bundles/agent-workspace.wrapper.zsh
: "${ZDOTDIR:=$HOME/.config/zsh}"
export ZDOTDIR
export ZSH_CONFIG_DIR="${ZSH_CONFIG_DIR:-$ZDOTDIR/config}"
export ZSH_BOOTSTRAP_SCRIPT_DIR="${ZSH_BOOTSTRAP_SCRIPT_DIR:-$ZDOTDIR/bootstrap}"
export ZSH_SCRIPT_DIR="${ZSH_SCRIPT_DIR:-$ZDOTDIR/scripts}"

# --- BEGIN _features/agent-workspace/alias.zsh
# Feature: agent-workspace aliases
#
# Provides short aliases for agent-workspace helpers.
# - `cw`   -> `agent-workspace`
# - `cw*`  -> `agent-workspace <subcommand> ...`
# - `cwa*` -> `agent-workspace auth ...`
# - `cwr*` -> `agent-workspace reset ...`

if command -v safe_unalias >/dev/null; then
  safe_unalias \
    cw \
    cwa cwac cwah cwag \
    cwc cwl cwe \
    cwr cwrr cwrw cwro cwrp \
    cwm cwt
fi

# cw
# Alias of `agent-workspace`.
# Usage: cw <subcommand> [args...]
alias cw='agent-workspace'

# ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
# agent-workspace subcommands (cw*)
# ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

# cwa
# Alias of `agent-workspace auth`.
# Usage: cwa <provider> [args...]
alias cwa='agent-workspace auth'

# cwac
# Alias of `agent-workspace auth codex`.
# Usage: cwac [args...]
alias cwac='agent-workspace auth codex'

# cwah
# Alias of `agent-workspace auth github`.
# Usage: cwah [args...]
alias cwah='agent-workspace auth github'

# cwag
# Alias of `agent-workspace auth gpg`.
# Usage: cwag [args...]
alias cwag='agent-workspace auth gpg'

# cwc
# Alias of `agent-workspace create`.
# Usage: cwc [args...]
alias cwc='agent-workspace create'

# cwl
# Alias of `agent-workspace ls`.
# Usage: cwl [args...]
alias cwl='agent-workspace ls'

# cwe
# Alias of `agent-workspace exec`.
# Usage: cwe [args...]
alias cwe='agent-workspace exec'

# cwr
# Alias of `agent-workspace reset`.
# Usage: cwr <command> [args...]
alias cwr='agent-workspace reset'

# cwrr
# Alias of `agent-workspace reset repo`.
# Usage: cwrr [args...]
alias cwrr='agent-workspace reset repo'

# cwrw
# Alias of `agent-workspace reset work-repos`.
# Usage: cwrw [args...]
alias cwrw='agent-workspace reset work-repos'

# cwro
# Alias of `agent-workspace reset opt-repos`.
# Usage: cwro [args...]
alias cwro='agent-workspace reset opt-repos'

# cwrp
# Alias of `agent-workspace reset private-repo`.
# Usage: cwrp [args...]
alias cwrp='agent-workspace reset private-repo'

# cwm
# Alias of `agent-workspace rm`.
# Usage: cwm [args...]
alias cwm='agent-workspace rm'

# cwt
# Alias of `agent-workspace tunnel`.
# Usage: cwt [args...]
alias cwt='agent-workspace tunnel'

# --- END _features/agent-workspace/alias.zsh

# --- BEGIN _features/agent-workspace/repo-reset.zsh
# Repo reset helpers for Codex workspace containers (feature: agent-workspace).
#
# Public functions:
#   - agent-workspace-reset <subcommand> [args...]
#   - agent-workspace-refresh-opt-repos <container> [--yes]
#   - agent-workspace-reset-repo <container> <repo_dir> [--ref <remote/branch>] [--yes]
#   - agent-workspace-reset-private-repo <container> [--ref <remote/branch>] [--yes]
#   - agent-workspace-reset-work-repos <container> [--root <dir>] [--depth <N>] [--ref <remote/branch>] [--yes]

# _codex_workspace_confirm <prompt>
# Prompt for y/N confirmation (returns 0 only on "y"/"Y").
_codex_workspace_confirm() {
  emulate -L zsh

  local prompt="${1-}"
  [[ -n "$prompt" ]] || return 1
  shift || true

  print -n -r -- "$prompt"

  local confirm=''
  IFS= read -r confirm
  [[ "$confirm" == [yY] ]]
}

# _codex_workspace_confirm_or_abort <prompt>
# Prompt for confirmation; print "Aborted" and return non-zero on decline.
_codex_workspace_confirm_or_abort() {
  _codex_workspace_confirm "$@" && return 0
  print -r -- "üö´ Aborted"
  return 1
}

# _codex_workspace_print_folders [paths...]
# Print a bullet list of folders/paths.
_codex_workspace_print_folders() {
  emulate -L zsh

  local folder=''
  for folder in "$@"; do
    print -r -- "  - $folder"
  done
}

# _codex_workspace_require_docker
# Ensure `docker` is available on the host.
_codex_workspace_require_docker() {
  emulate -L zsh

  if ! command -v docker >/dev/null 2>&1; then
    print -u2 -r -- "error: docker not found on host"
    return 1
  fi
  return 0
}

# _codex_workspace_require_container <container>
# Ensure the workspace container exists on the host.
_codex_workspace_require_container() {
  emulate -L zsh

  local container="${1:-}"
  if [[ -z "$container" ]]; then
    print -u2 -r -- "error: missing container name"
    return 2
  fi

  if ! docker inspect "$container" >/dev/null 2>&1; then
    print -u2 -r -- "error: workspace container not found: $container"
    return 1
  fi
  return 0
}

# _codex_workspace_container_reset_repo <container> <repo_dir> [ref]
# Reset a repo inside a workspace container to a remote-tracking ref.
_codex_workspace_container_reset_repo() {
  emulate -L zsh
  setopt pipe_fail

  local container="${1:?missing container}"
  local repo_dir="${2:?missing repo_dir}"
  local ref="${3:-origin/main}"

  docker exec -i -u codex "$container" zsh -s -- "$repo_dir" "$ref" <<'EOF'
set -euo pipefail

repo_dir="${1:?missing repo_dir}"
ref="${2:-origin/main}"

# _load_git_reset_remote
# Load git-reset-remote when available (preferred: function, fallback: zsh-kit file).
_load_git_reset_remote() {
  if typeset -f git-reset-remote >/dev/null 2>&1; then
    return 0
  fi
  if [[ -f /opt/zsh-kit/scripts/git/tools/git-reset.zsh ]]; then
    source /opt/zsh-kit/scripts/git/tools/git-reset.zsh
    return 0
  fi
  return 1
}

# _resolve_target_ref <remote/branch>
# Resolve and validate a remote-tracking ref (fallbacks: remote/HEAD, then remote/master).
_resolve_target_ref() {
  local ref="$1"
  local remote="${ref%%/*}"
  local branch="${ref#*/}"

  if [[ "$remote" == "$ref" || -z "$remote" || -z "$branch" ]]; then
    print -u2 -r -- "error: invalid ref (expected remote/branch): $ref"
    return 2
  fi

  # Ensure remote-tracking branches are up-to-date.
  git fetch --prune -- "$remote" >/dev/null 2>&1 || git fetch --prune -- "$remote"

  if git show-ref --verify --quiet "refs/remotes/$remote/$branch"; then
    print -r -- "$remote/$branch"
    return 0
  fi

  # Fallback: use remote HEAD if set.
  local default_ref=''
  default_ref="$(git symbolic-ref -q --short "refs/remotes/$remote/HEAD" 2>/dev/null || true)"
  local default_branch="${default_ref#${remote}/}"
  if [[ -n "$default_branch" && "$default_branch" != "$default_ref" ]]; then
    if git show-ref --verify --quiet "refs/remotes/$remote/$default_branch"; then
      print -u2 -r -- "warn: $remote/$branch not found; using $remote/$default_branch (from $remote/HEAD)"
      print -r -- "$remote/$default_branch"
      return 0
    fi
  fi

  if git show-ref --verify --quiet "refs/remotes/$remote/master"; then
    print -u2 -r -- "warn: $remote/$branch not found; using $remote/master"
    print -r -- "$remote/master"
    return 0
  fi

  print -u2 -r -- "error: remote branch not found: $remote/$branch"
  return 1
}

# _force_checkout_branch <branch> [start_point]
# Force checkout a branch, cleaning untracked files if needed.
_force_checkout_branch() {
  local branch="$1"
  local start_point="${2:-}"

  if [[ -n "$start_point" ]]; then
    git checkout --force -B "$branch" "$start_point" >/dev/null 2>&1 && return 0
    git clean -fd >/dev/null 2>&1 || true
    git checkout --force -B "$branch" "$start_point"
    return $?
  fi

  git checkout --force "$branch" >/dev/null 2>&1 && return 0
  git clean -fd >/dev/null 2>&1 || true
  git checkout --force "$branch"
}

# _reset_repo_to_ref <repo_dir> <remote/branch>
# Reset a repo dir to the resolved remote-tracking ref (hard reset + clean).
_reset_repo_to_ref() {
  local repo_dir="$1"
  local ref="$2"

  if [[ ! -e "$repo_dir/.git" ]]; then
    print -u2 -r -- "error: not a git repo: $repo_dir"
    return 1
  fi

  cd "$repo_dir"

  local resolved_ref=''
  resolved_ref="$(_resolve_target_ref "$ref")" || return $?

  local branch="${resolved_ref#*/}"

  print -r -- "+ reset $repo_dir -> $resolved_ref"

  if git show-ref --verify --quiet "refs/heads/$branch"; then
    _force_checkout_branch "$branch"
  else
    _force_checkout_branch "$branch" "$resolved_ref"
  fi

  if _load_git_reset_remote; then
    git-reset-remote --ref "$resolved_ref" --no-fetch --clean --yes
    return 0
  fi

  git reset --hard "$resolved_ref"
  git clean -fd
}

_reset_repo_to_ref "$repo_dir" "$ref"
EOF
}

# _codex_workspace_container_list_git_repos <container> [root] [depth]
# List git repo dirs under <root> inside a workspace container.
_codex_workspace_container_list_git_repos() {
  emulate -L zsh
  setopt pipe_fail

  local container="${1:?missing container}"
  local root="${2:-/work}"
  local depth="${3:-2}"

  docker exec -i -u codex "$container" zsh -s -- "$root" "$depth" <<'EOF'
set -euo pipefail

root="${1:?missing root}"
depth="${2:?missing depth}"

if [[ "$depth" != <-> || "$depth" -le 0 ]]; then
  print -u2 -r -- "error: --depth must be a positive integer (got: $depth)"
  exit 2
fi

if [[ ! -d "$root" ]]; then
  print -u2 -r -- "error: root not found: $root"
  exit 1
fi

	typeset -i git_depth=$((depth + 1))
	typeset -a repos=()

	while IFS= read -r -d '' git_entry; do
	  repos+=("${git_entry:h}")
	done < <(find -L "$root" -maxdepth "$git_depth" -mindepth 2 \( -type d -o -type f \) -name .git -print0 2>/dev/null)

print -rl -- ${(ou)repos}
EOF
}

# agent-workspace-reset <subcommand> [args...]
# Reset helpers under the `agent-workspace reset ...` namespace.
agent-workspace-reset() {
  emulate -L zsh
  setopt pipe_fail

  local subcmd="${1:-}"
  case "$subcmd" in
    ""|-h|--help)
      cat <<'EOF'
usage:
  agent-workspace reset repo <name|container> <repo_dir> [--ref <remote/branch>] [--yes]
  agent-workspace reset work-repos <name|container> [--root <dir>] [--depth <N>] [--ref <remote/branch>] [--yes]
  agent-workspace reset opt-repos <name|container> [--yes]
  agent-workspace reset private-repo <name|container> [--ref <remote/branch>] [--yes]

subcommands:
  repo         Reset a single repo inside the container
  work-repos   Reset all git repos under a root dir (default: /work)
  opt-repos    Refresh /opt/agent-kit + /opt/zsh-kit inside the container
  private-repo Reset ~/.private inside the container
EOF
      return 0
      ;;
    repo)
      shift 1 2>/dev/null || true
      agent-workspace-reset-repo "$@"
      return $?
      ;;
    work-repos)
      shift 1 2>/dev/null || true
      agent-workspace-reset-work-repos "$@"
      return $?
      ;;
    opt-repos)
      shift 1 2>/dev/null || true
      agent-workspace-refresh-opt-repos "$@"
      return $?
      ;;
    private-repo)
      shift 1 2>/dev/null || true
      agent-workspace-reset-private-repo "$@"
      return $?
      ;;
    *)
      print -u2 -r -- "error: unknown reset subcommand: $subcmd"
      print -u2 -r -- "hint: agent-workspace reset --help"
      return 2
      ;;
  esac
}

# agent-workspace-reset-repo <container> <repo_dir> [--ref <remote/branch>] [--yes]
# Reset a single repo inside a workspace container.
agent-workspace-reset-repo() {
  emulate -L zsh
  setopt pipe_fail

  local name="${1:-}"
  local repo_dir="${2:-}"
  if [[ -z "$name" || "$name" == "-h" || "$name" == "--help" ]]; then
    cat <<'EOF'
usage: agent-workspace-reset-repo <name|container> <repo_dir> [--ref <remote/branch>] [--yes]

Reset a repo inside a workspace container to a remote-tracking branch.
Defaults:
  --ref origin/main
Notes:
  - Forces checkout to the target branch before resetting.
  - Discards tracked changes (hard reset) and removes untracked files/dirs (git clean -fd).
EOF
    return 0
  fi

  if [[ -z "$repo_dir" ]]; then
    print -u2 -r -- "error: missing required args"
    print -u2 -r -- "hint: agent-workspace-reset-repo <container> <repo_dir> [--ref origin/main]"
    return 2
  fi

  shift 2 2>/dev/null || true

  local ref="origin/main"
  local want_yes=0

  while [[ $# -gt 0 ]]; do
    case "$1" in
      --ref)
        ref="${2:-}"
        shift 2 || break
        ;;
      -y|--yes)
        want_yes=1
        shift
        ;;
      -h|--help)
        cat <<'EOF'
usage: agent-workspace-reset-repo <name|container> <repo_dir> [--ref <remote/branch>] [--yes]

Reset a repo inside a workspace container to a remote-tracking branch.
Defaults:
  --ref origin/main
Notes:
  - Forces checkout to the target branch before resetting.
  - Discards tracked changes (hard reset) and removes untracked files/dirs (git clean -fd).
EOF
        return 0
        ;;
      *)
        print -u2 -r -- "error: unknown arg: $1"
        return 2
        ;;
    esac
  done

  if [[ -z "$name" || -z "$repo_dir" ]]; then
    print -u2 -r -- "error: missing required args"
    print -u2 -r -- "hint: agent-workspace-reset-repo <container> <repo_dir> [--ref origin/main]"
    return 2
  fi

  _codex_workspace_require_docker || return $?
  local container=''
  if (( $+functions[_codex_workspace_normalize_container_name] )); then
    container="$(_codex_workspace_normalize_container_name "$name")" || return 1
  else
    local prefix="${AGENT_WORKSPACE_PREFIX:-codex-ws}"
    if [[ "$name" == "${prefix}-"* ]]; then
      container="$name"
    else
      container="${prefix}-${name}"
    fi
  fi
  _codex_workspace_require_container "$container" || return $?

  if (( !want_yes )); then
    print -r -- "This will reset a repo inside container: $container"
    _codex_workspace_print_folders "$repo_dir"
    print -r --
    print -r -- "Actions:"
    print -r -- "  - Force checkout to target branch (default: main)"
    print -r -- "  - git reset --hard <remote/branch> (DISCARDS tracked changes)"
    print -r -- "  - git clean -fd (REMOVES untracked files/dirs)"
    _codex_workspace_confirm_or_abort "‚ùì Proceed? [y/N] " || return 1
  fi

  _codex_workspace_container_reset_repo "$container" "$repo_dir" "$ref"
}

# agent-workspace-reset-private-repo <container> [--ref <remote/branch>] [--yes]
# Reset ~/.private inside a workspace container.
agent-workspace-reset-private-repo() {
  emulate -L zsh
  setopt pipe_fail

  local name="${1:-}"
  if [[ -z "$name" || "$name" == "-h" || "$name" == "--help" ]]; then
    cat <<'EOF'
usage: agent-workspace-reset-private-repo <name|container> [--ref <remote/branch>] [--yes]

Reset ~/.private inside a workspace container to a remote-tracking branch.
Defaults:
  --ref origin/main
Notes:
  - If ~/.private is missing (or not a git repo), this is a no-op.
  - Discards tracked changes (hard reset) and removes untracked files/dirs (git clean -fd).
EOF
    return 0
  fi

  shift 1 2>/dev/null || true

  local ref="origin/main"
  local want_yes=0

  while [[ $# -gt 0 ]]; do
    case "$1" in
      --ref)
        ref="${2:-}"
        shift 2 || break
        ;;
      -y|--yes)
        want_yes=1
        shift
        ;;
      -h|--help)
        cat <<'EOF'
usage: agent-workspace-reset-private-repo <name|container> [--ref <remote/branch>] [--yes]

Reset ~/.private inside a workspace container to a remote-tracking branch.
Defaults:
  --ref origin/main
Notes:
  - If ~/.private is missing (or not a git repo), this is a no-op.
  - Discards tracked changes (hard reset) and removes untracked files/dirs (git clean -fd).
EOF
        return 0
        ;;
      *)
        print -u2 -r -- "error: unknown arg: $1"
        return 2
        ;;
    esac
  done

  if [[ -z "$name" ]]; then
    print -u2 -r -- "error: missing container"
    print -u2 -r -- "hint: agent-workspace-reset-private-repo <container> [--ref origin/main]"
    return 2
  fi

  _codex_workspace_require_docker || return $?
  local container=''
  if (( $+functions[_codex_workspace_normalize_container_name] )); then
    container="$(_codex_workspace_normalize_container_name "$name")" || return 1
  else
    local prefix="${AGENT_WORKSPACE_PREFIX:-codex-ws}"
    if [[ "$name" == "${prefix}-"* ]]; then
      container="$name"
    else
      container="${prefix}-${name}"
    fi
  fi
  _codex_workspace_require_container "$container" || return $?

  local repo_dir="/home/agent/.private"

  if ! docker exec -u codex "$container" bash -lc 'test -d "$HOME/.private/.git"' >/dev/null 2>&1; then
    print -u2 -r -- "warn: ~/.private not found (or not a git repo) in container: $container"
    print -u2 -r -- "hint: seed it with: AGENT_WORKSPACE_PRIVATE_REPO=OWNER/REPO agent-workspace create ..."
    return 0
  fi

  if (( !want_yes )); then
    print -r -- "This will reset ~/.private inside container: $container"
    _codex_workspace_print_folders "$repo_dir"
    print -r --
    print -r -- "Actions:"
    print -r -- "  - Force checkout to target branch (default: main)"
    print -r -- "  - git reset --hard <remote/branch> (DISCARDS tracked changes)"
    print -r -- "  - git clean -fd (REMOVES untracked files/dirs)"
    _codex_workspace_confirm_or_abort "‚ùì Proceed? [y/N] " || return 1
  fi

  _codex_workspace_container_reset_repo "$container" "$repo_dir" "$ref"
}

# agent-workspace-reset-work-repos <container> [--root <dir>] [--depth <N>] [--ref <remote/branch>] [--yes]
# Reset all git repos under a root directory inside a workspace container.
agent-workspace-reset-work-repos() {
  emulate -L zsh
  setopt pipe_fail

  local name="${1:-}"
  if [[ -z "$name" || "$name" == "-h" || "$name" == "--help" ]]; then
    cat <<'EOF'
usage: agent-workspace-reset-work-repos <name|container> [--root <dir>] [--depth <N>] [--ref <remote/branch>] [--yes]

	Reset all git repos under a root directory inside a workspace container.
	Defaults:
	  --root /work
	  --depth 3          # repo roots up to: /work/*/*/*
	  --ref origin/main
EOF
    return 0
  fi

  shift 1 2>/dev/null || true

  local root="/work"
  local depth="3"
  local ref="origin/main"
  local want_yes=0

  while [[ $# -gt 0 ]]; do
    case "$1" in
      --root)
        root="${2:-}"
        shift 2 || break
        ;;
      --depth)
        depth="${2:-}"
        shift 2 || break
        ;;
      --ref)
        ref="${2:-}"
        shift 2 || break
        ;;
      -y|--yes)
        want_yes=1
        shift
        ;;
      -h|--help)
        cat <<'EOF'
usage: agent-workspace-reset-work-repos <name|container> [--root <dir>] [--depth <N>] [--ref <remote/branch>] [--yes]

	Reset all git repos under a root directory inside a workspace container.
	Defaults:
	  --root /work
	  --depth 3          # repo roots up to: /work/*/*/*
	  --ref origin/main
EOF
        return 0
        ;;
      *)
        print -u2 -r -- "error: unknown arg: $1"
        return 2
        ;;
    esac
  done

  if [[ -z "$name" ]]; then
    print -u2 -r -- "error: missing container"
    print -u2 -r -- "hint: agent-workspace-reset-work-repos <container> [--depth 3]"
    return 2
  fi

  _codex_workspace_require_docker || return $?
  local container=''
  if (( $+functions[_codex_workspace_normalize_container_name] )); then
    container="$(_codex_workspace_normalize_container_name "$name")" || return 1
  else
    local prefix="${AGENT_WORKSPACE_PREFIX:-codex-ws}"
    if [[ "$name" == "${prefix}-"* ]]; then
      container="$name"
    else
      container="${prefix}-${name}"
    fi
  fi
  _codex_workspace_require_container "$container" || return $?

  local repos_out=''
  repos_out="$(_codex_workspace_container_list_git_repos "$container" "$root" "$depth")" || return $?

  if [[ -z "$repos_out" ]]; then
    print -u2 -r -- "warn: no git repos found under $root (depth=$depth) in $container"
    return 0
  fi

  local -a repo_dirs=()
  repo_dirs=("${(@f)repos_out}")

  if (( !want_yes )); then
    print -r -- "This will reset ${#repo_dirs} repos inside container: $container"
    _codex_workspace_print_folders "${repo_dirs[@]}"
    print -r --
    print -r -- "Actions:"
    print -r -- "  - Force checkout to target branch (default: main)"
    print -r -- "  - git reset --hard <remote/branch> (DISCARDS tracked changes)"
    print -r -- "  - git clean -fd (REMOVES untracked files/dirs)"
    _codex_workspace_confirm_or_abort "‚ùì Proceed? [y/N] " || return 1
  fi

  local reset_script=''
  reset_script="$(cat <<'EOF'
set -euo pipefail

ref="${1:-origin/main}"

# _load_git_reset_remote
# Load git-reset-remote when available (preferred: function, fallback: zsh-kit file).
_load_git_reset_remote() {
  if typeset -f git-reset-remote >/dev/null 2>&1; then
    return 0
  fi
  if [[ -f /opt/zsh-kit/scripts/git/tools/git-reset.zsh ]]; then
    source /opt/zsh-kit/scripts/git/tools/git-reset.zsh
    return 0
  fi
  return 1
}

# _resolve_target_ref <remote/branch>
# Resolve and validate a remote-tracking ref (fallbacks: remote/HEAD, then remote/master).
_resolve_target_ref() {
  local ref="$1"
  local remote="${ref%%/*}"
  local branch="${ref#*/}"

  if [[ "$remote" == "$ref" || -z "$remote" || -z "$branch" ]]; then
    print -u2 -r -- "error: invalid ref (expected remote/branch): $ref"
    return 2
  fi

  git fetch --prune -- "$remote" >/dev/null 2>&1 || git fetch --prune -- "$remote"

  if git show-ref --verify --quiet "refs/remotes/$remote/$branch"; then
    print -r -- "$remote/$branch"
    return 0
  fi

  local default_ref=''
  default_ref="$(git symbolic-ref -q --short "refs/remotes/$remote/HEAD" 2>/dev/null || true)"
  local default_branch="${default_ref#${remote}/}"
  if [[ -n "$default_branch" && "$default_branch" != "$default_ref" ]]; then
    if git show-ref --verify --quiet "refs/remotes/$remote/$default_branch"; then
      print -u2 -r -- "warn: $remote/$branch not found; using $remote/$default_branch (from $remote/HEAD)"
      print -r -- "$remote/$default_branch"
      return 0
    fi
  fi

  if git show-ref --verify --quiet "refs/remotes/$remote/master"; then
    print -u2 -r -- "warn: $remote/$branch not found; using $remote/master"
    print -r -- "$remote/master"
    return 0
  fi

  print -u2 -r -- "error: remote branch not found: $remote/$branch"
  return 1
}

# _force_checkout_branch <branch> [start_point]
# Force checkout a branch, cleaning untracked files if needed.
_force_checkout_branch() {
  local branch="$1"
  local start_point="${2:-}"

  if [[ -n "$start_point" ]]; then
    git checkout --force -B "$branch" "$start_point" >/dev/null 2>&1 && return 0
    git clean -fd >/dev/null 2>&1 || true
    git checkout --force -B "$branch" "$start_point"
    return $?
  fi

  git checkout --force "$branch" >/dev/null 2>&1 && return 0
  git clean -fd >/dev/null 2>&1 || true
  git checkout --force "$branch"
}

# _reset_repo_to_ref <repo_dir> <remote/branch>
# Reset a repo dir to the resolved remote-tracking ref (hard reset + clean).
_reset_repo_to_ref() {
  local repo_dir="$1"
  local ref="$2"

  if [[ ! -e "$repo_dir/.git" ]]; then
    print -u2 -r -- "warn: missing git repo: $repo_dir"
    return 0
  fi

  cd "$repo_dir"

  local resolved_ref=''
  resolved_ref="$(_resolve_target_ref "$ref")" || return $?

  local branch="${resolved_ref#*/}"

  print -r -- "+ reset $repo_dir -> $resolved_ref"

  if git show-ref --verify --quiet "refs/heads/$branch"; then
    _force_checkout_branch "$branch"
  else
    _force_checkout_branch "$branch" "$resolved_ref"
  fi

  if _load_git_reset_remote; then
    git-reset-remote --ref "$resolved_ref" --no-fetch --clean --yes
    return 0
  fi

  git reset --hard "$resolved_ref"
  git clean -fd
}

typeset -i fail_count=0
while IFS= read -r repo_dir; do
  [[ -n "$repo_dir" ]] || continue
  if ! _reset_repo_to_ref "$repo_dir" "$ref"; then
    fail_count=$((fail_count + 1))
  fi
done

if (( fail_count > 0 )); then
  print -u2 -r -- "error: failed to reset $fail_count repo(s)"
  exit 1
	fi
EOF

)"

  # Feed repo dirs via stdin; pass the reset script via `zsh -c` to avoid stdin conflicts.
  print -r -- "$repos_out" | docker exec -i -u codex "$container" zsh -c "$reset_script" -- "$ref"
}

# agent-workspace-refresh-opt-repos <name|container> [--yes]
# Force-update the image-bundled repos inside a workspace container, then sync agent-kit.
agent-workspace-refresh-opt-repos() {
  emulate -L zsh
  setopt pipe_fail

  local name="${1:-}"
  if [[ -z "$name" || "$name" == "-h" || "$name" == "--help" ]]; then
    cat <<'EOF'
usage: agent-workspace-refresh-opt-repos <name|container> [--yes]

Force-update the image-bundled repos inside a workspace container:
  - /opt/agent-kit
  - /opt/zsh-kit

Notes:
  - Uses `git-reset-remote --yes` when available (fallback: git fetch/reset/clean).
  - Re-wires zsh-kit codex secrets symlink when secrets are mounted.
  - Syncs /opt/agent-kit -> $AGENT_HOME (default: /home/agent/.agents) via rsync.
  - Add --yes to skip the preflight confirmation prompt.
EOF
    return 0
  fi

  shift 1 2>/dev/null || true

  local want_yes=0
  while [[ $# -gt 0 ]]; do
    case "$1" in
      -y|--yes)
        want_yes=1
        shift
        ;;
      -h|--help)
        cat <<'EOF'
usage: agent-workspace-refresh-opt-repos <name|container> [--yes]

Force-update the image-bundled repos inside a workspace container:
  - /opt/agent-kit
  - /opt/zsh-kit

Notes:
  - Uses `git-reset-remote --yes` when available (fallback: git fetch/reset/clean).
  - Re-wires zsh-kit codex secrets symlink when secrets are mounted.
  - Syncs /opt/agent-kit -> $AGENT_HOME (default: /home/agent/.agents) via rsync.
  - Add --yes to skip the preflight confirmation prompt.
EOF
        return 0
        ;;
      *)
        print -u2 -r -- "error: unknown arg: $1"
        return 2
        ;;
    esac
  done

  if [[ -z "$name" ]]; then
    print -u2 -r -- "error: missing container"
    print -u2 -r -- "hint: agent-workspace-refresh-opt-repos <container>"
    return 2
  fi

  _codex_workspace_require_docker || return $?

  local container=''
  if (( $+functions[_codex_workspace_normalize_container_name] )); then
    container="$(_codex_workspace_normalize_container_name "$name")" || return 1
  else
    local prefix="${AGENT_WORKSPACE_PREFIX:-codex-ws}"
    if [[ "$name" == "${prefix}-"* ]]; then
      container="$name"
    else
      container="${prefix}-${name}"
    fi
  fi
  _codex_workspace_require_container "$container" || return $?

  local -a repo_dirs=(/opt/agent-kit /opt/zsh-kit)
  if (( !want_yes )); then
    print -r -- "This will reset /opt repos inside container: $container"
    _codex_workspace_print_folders "${repo_dirs[@]}"
    print -r --
    print -r -- "Actions:"
    print -r -- "  - Force checkout to target branch (default: main)"
    print -r -- "  - git reset --hard <remote/branch> (DISCARDS tracked changes)"
    print -r -- "  - git clean -fd (REMOVES untracked files/dirs)"
    _codex_workspace_confirm_or_abort "‚ùì Proceed? [y/N] " || return 1
  fi

  print -r -- "+ refresh /opt repos in $container"
  docker exec -i -u codex "$container" zsh -s -- <<'EOF'
set -euo pipefail

if command -v gh >/dev/null 2>&1; then
  gh config set git_protocol https -h github.com 2>/dev/null || gh config set git_protocol https 2>/dev/null || true
fi

codex_home="${AGENT_HOME:-/home/agent/.agents}"
codex_src="/opt/agent-kit"

# _restore_zsh_kit_codex_secrets_mount <dst>
# If secrets are mounted outside the default, restore the zsh-kit codex secrets symlink.
_restore_zsh_kit_codex_secrets_mount() {
  local src="/opt/zsh-kit/scripts/_features/codex/secrets"
  local dst="${1:-}"
  [[ -n "$dst" ]] || return 0
  [[ "$dst" != "$src" ]] || return 0
  [[ -d "$dst" ]] || return 0

  if [[ ! -f "$dst/codex-secret.zsh" ]]; then
    local -a json_files=("$dst"/*.json(N))
    (( ${#json_files} > 0 )) || return 0
  fi

  if [[ -L "$src" && "$(readlink "$src" 2>/dev/null || true)" == "$dst" ]]; then
    return 0
  fi

  rm -rf "$src"
  ln -s "$dst" "$src"
}

# _load_git_reset_remote
# Load git-reset-remote when available (preferred: function, fallback: zsh-kit file).
_load_git_reset_remote() {
  if typeset -f git-reset-remote >/dev/null 2>&1; then
    return 0
  fi
  if [[ -f /opt/zsh-kit/scripts/git/tools/git-reset.zsh ]]; then
    source /opt/zsh-kit/scripts/git/tools/git-reset.zsh
    return 0
  fi
  return 1
}

# _resolve_target_ref <remote/branch>
# Resolve and validate a remote-tracking ref (fallbacks: remote/HEAD, then remote/master).
_resolve_target_ref() {
  local ref="$1"
  local remote="${ref%%/*}"
  local branch="${ref#*/}"

  if [[ "$remote" == "$ref" || -z "$remote" || -z "$branch" ]]; then
    print -u2 -r -- "error: invalid ref (expected remote/branch): $ref"
    return 2
  fi

  git fetch --prune -- "$remote" >/dev/null 2>&1 || git fetch --prune -- "$remote"

  if git show-ref --verify --quiet "refs/remotes/$remote/$branch"; then
    print -r -- "$remote/$branch"
    return 0
  fi

  local default_ref=''
  default_ref="$(git symbolic-ref -q --short "refs/remotes/$remote/HEAD" 2>/dev/null || true)"
  local default_branch="${default_ref#${remote}/}"
  if [[ -n "$default_branch" && "$default_branch" != "$default_ref" ]]; then
    if git show-ref --verify --quiet "refs/remotes/$remote/$default_branch"; then
      print -u2 -r -- "warn: $remote/$branch not found; using $remote/$default_branch (from $remote/HEAD)"
      print -r -- "$remote/$default_branch"
      return 0
    fi
  fi

  if git show-ref --verify --quiet "refs/remotes/$remote/master"; then
    print -u2 -r -- "warn: $remote/$branch not found; using $remote/master"
    print -r -- "$remote/master"
    return 0
  fi

  print -u2 -r -- "error: remote branch not found: $remote/$branch"
  return 1
}

# _force_checkout_branch <branch> [start_point]
# Force checkout a branch, cleaning untracked files if needed.
_force_checkout_branch() {
  local branch="$1"
  local start_point="${2:-}"

  if [[ -n "$start_point" ]]; then
    git checkout --force -B "$branch" "$start_point" >/dev/null 2>&1 && return 0
    git clean -fd >/dev/null 2>&1 || true
    git checkout --force -B "$branch" "$start_point"
    return $?
  fi

  git checkout --force "$branch" >/dev/null 2>&1 && return 0
  git clean -fd >/dev/null 2>&1 || true
  git checkout --force "$branch"
}

# _reset_repo_to_ref <repo_dir> <remote/branch>
# Reset a repo dir to the resolved remote-tracking ref (hard reset + clean).
_reset_repo_to_ref() {
  local repo_dir="$1"
  local ref="$2"

  if [[ ! -d "$repo_dir" || ! -e "$repo_dir/.git" ]]; then
    print -u2 -r -- "warn: missing git repo: $repo_dir"
    return 0
  fi

  cd "$repo_dir"

  local resolved_ref=''
  resolved_ref="$(_resolve_target_ref "$ref")" || return $?

  local branch="${resolved_ref#*/}"

  print -r -- "+ reset $repo_dir -> $resolved_ref"

  if git show-ref --verify --quiet "refs/heads/$branch"; then
    _force_checkout_branch "$branch"
  else
    _force_checkout_branch "$branch" "$resolved_ref"
  fi

  if _load_git_reset_remote; then
    git-reset-remote --ref "$resolved_ref" --no-fetch --clean --yes
    return 0
  fi

  print -u2 -r -- "warn: git-reset-remote not found; falling back to git reset/clean ($repo_dir)"
  git reset --hard "$resolved_ref"
  git clean -fd
}

# _detect_codex_secrets_mount
# Detect the codex secrets mount path in the container (symlink or common defaults).
_detect_codex_secrets_mount() {
  local src="/opt/zsh-kit/scripts/_features/codex/secrets"
  local dst=''

  if [[ -L "$src" ]]; then
    dst="$(readlink "$src" 2>/dev/null || true)"
  fi

  if [[ -z "$dst" && -n "${CODEX_SECRET_DIR-}" ]]; then
    dst="${CODEX_SECRET_DIR-}"
  fi

  if [[ -z "$dst" && -d "$HOME/AGENT_secrets" ]]; then
    if [[ -f "$HOME/AGENT_secrets/codex-secret.zsh" ]]; then
      dst="$HOME/AGENT_secrets"
    else
      local -a json_files=("$HOME/AGENT_secrets"/*.json(N))
      (( ${#json_files} > 0 )) && dst="$HOME/AGENT_secrets"
    fi
  fi

  if [[ -z "$dst" && -d /home/agent/AGENT_secrets ]]; then
    if [[ -f /home/agent/AGENT_secrets/codex-secret.zsh ]]; then
      dst="/home/agent/AGENT_secrets"
    else
      local -a json_files=(/home/agent/AGENT_secrets/*.json(N))
      (( ${#json_files} > 0 )) && dst="/home/agent/AGENT_secrets"
    fi
  fi

  [[ -n "$dst" ]] || return 1
  print -r -- "$dst"
}

codex_secrets_mount="$(_detect_codex_secrets_mount 2>/dev/null || true)"

_reset_repo_to_ref /opt/agent-kit origin/main
_reset_repo_to_ref /opt/zsh-kit origin/main
_restore_zsh_kit_codex_secrets_mount "$codex_secrets_mount"

if ! command -v rsync >/dev/null 2>&1; then
  print -u2 -r -- "warn: rsync not available; skipped /opt/agent-kit -> ${codex_home} sync"
  exit 0
fi

mkdir -p "$codex_home"
print -r -- "+ rsync /opt/agent-kit -> ${codex_home} (delete + excludes)"
rsync -a --delete \
  --exclude='.env' \
  --exclude='.venv' \
  --exclude='AGENTS.override.md' \
  --exclude='auth.json' \
  --exclude='history.jsonl' \
  --exclude='config.toml' \
  --exclude='out/' \
  --exclude='log/' \
  --exclude='sessions/' \
  --exclude='shell_snapshots/' \
  --exclude='tmp/' \
  "${codex_src%/}/" "${codex_home%/}/"
EOF
}

# --- END _features/agent-workspace/repo-reset.zsh

# --- BEGIN _features/agent-workspace/workspace-rm.zsh
# Host helper to remove a Codex workspace container and its named volumes (feature: agent-workspace).
#
# Usage:
#   agent-workspace-rm <name|container> [--yes]
#   agent-workspace-rm --all [--yes]
#
# Notes:
#   - Delegates workspace removal to the agent-kit launcher (canonical).
#   - Removes volumes by default; pass `--keep-volumes` to preserve volumes.
#   - `--volumes` is accepted for backwards compatibility (no-op; launcher removes volumes by default).

# _codex_workspace_normalize_container_name <name>
# Normalize a workspace name into a docker container name (adds AGENT_WORKSPACE_PREFIX when needed).
_codex_workspace_normalize_container_name() {
  emulate -L zsh

  local name="${1:-}"
  [[ -n "$name" ]] || return 1

  local prefix="${AGENT_WORKSPACE_PREFIX:-codex-ws}"
  if [[ "$name" == "${prefix}-"* ]]; then
    print -r -- "$name"
    return 0
  fi

  print -r -- "${prefix}-${name}"
  return 0
}

# _codex_workspace_volume_names <container>
# Print the 3 named volumes used by a workspace container (one per line).
_codex_workspace_volume_names() {
  emulate -L zsh

  local container="${1:-}"
  [[ -n "$container" ]] || return 1

  print -r -- "${container}-work"
  print -r -- "${container}-home"
  print -r -- "${container}-codex-home"
}

# _codex_workspace_container_names
# Print detected workspace container names (one per line).
_codex_workspace_container_names() {
  emulate -L zsh
  setopt pipe_fail

  _codex_workspace_require_docker || return $?

  local -a names=()
  names=(${(f)"$(docker ps -a --filter 'label=agent-kit.workspace=1' --format '{{.Names}}' 2>/dev/null || true)"})

  if (( ${#names[@]} == 0 )); then
    local prefix="${AGENT_WORKSPACE_PREFIX:-codex-ws}"
    names=(${(f)"$(docker ps -a --format '{{.Names}}' 2>/dev/null || true)"})

    local -a filtered=()
    local name=''
    for name in "${names[@]}"; do
      [[ "$name" == "${prefix}-"* ]] || continue
      filtered+=("$name")
    done
    names=("${filtered[@]}")
  fi

  local name=''
  for name in "${names[@]}"; do
    [[ -n "$name" ]] || continue
    print -r -- "$name"
  done

  return 0
}

# _codex_workspace_resolve_launcher_for_callthrough
# Resolve an executable launcher path for call-through commands (ls/rm).
_codex_workspace_resolve_launcher_for_callthrough() {
  emulate -L zsh
  setopt pipe_fail

  local launcher="${AGENT_WORKSPACE_LAUNCHER-}"
  local -i launcher_explicit=0
  if [[ -n "${launcher//[[:space:]]/}" ]]; then
    launcher_explicit=1
  else
    if (( $+functions[_codex_workspace_launcher_default_path] )); then
      launcher="$(_codex_workspace_launcher_default_path)"
    else
      launcher="$HOME/.config/agent-kit/docker/agent-env/bin/agent-workspace"
    fi
  fi

  if (( $+functions[_codex_workspace_ensure_launcher] )); then
    launcher="$(_codex_workspace_ensure_launcher "$launcher" "$launcher_explicit")" || {
      if (( launcher_explicit )); then
        return 1
      fi
      print -u2 -r -- "hint: set AGENT_WORKSPACE_LAUNCHER to a local launcher path"
      print -u2 -r -- "hint: or set AGENT_WORKSPACE_LAUNCHER_URL to override the download URL"
      return 1
    }
  else
    if [[ ! -x "$launcher" ]]; then
      print -u2 -r -- "error: launcher not found or not executable: $launcher"
      return 1
    fi
  fi

  print -r -- "$launcher"
  return 0
}

# agent-workspace-list
# List workspace containers (one per line).
agent-workspace-list() {
  emulate -L zsh
  setopt pipe_fail

  if (( $# > 1 )); then
    print -u2 -r -- "error: unexpected args: $*"
    return 2
  fi

  local arg1="${1:-}"
  if [[ -n "$arg1" && "$arg1" != "-h" && "$arg1" != "--help" ]]; then
    print -u2 -r -- "error: unknown arg: $arg1"
    return 2
  fi

  if [[ "$arg1" == "-h" || "$arg1" == "--help" ]]; then
    cat <<'EOF'
usage: agent-workspace ls

List workspace containers (one per line).
EOF
    return 0
  fi

  _codex_workspace_require_docker || return $?
  if ! docker info >/dev/null 2>&1; then
    print -u2 -r -- "error: docker daemon not running (start OrbStack/Docker Desktop)"
    return 1
  fi

  local launcher=''
  launcher="$(_codex_workspace_resolve_launcher_for_callthrough)" || return $?

  "$launcher" ls
  return $?
}

# _codex_workspace_rm_one <launcher> <name|container> [--keep-volumes] [--yes]
# Remove a single workspace container and its named volumes (delegates to launcher).
_codex_workspace_rm_one() {
  emulate -L zsh
  setopt pipe_fail

  local launcher="${1:-}"
  local name="${2:-}"
  local -i keep_volumes="${3:-0}"
  local -i want_yes="${4:-0}"

  if [[ -z "$launcher" || ! -x "$launcher" ]]; then
    print -u2 -r -- "error: launcher not found or not executable: $launcher"
    return 1
  fi

  if [[ -z "$name" ]]; then
    print -u2 -r -- "error: missing workspace name/container"
    print -u2 -r -- "hint: agent-workspace rm <name|container> [--yes]"
    return 2
  fi

  local container=''
  container="$(_codex_workspace_normalize_container_name "$name")" || return 1

  local -a rm_args=(rm "$container")
  if (( keep_volumes )); then
    rm_args+=(--keep-volumes)
  fi

  if (( !want_yes )); then
    print -r -- "This will REMOVE a workspace:"
    print -r -- "  - container: $container"
    print -r --
    print -r -- "Actions:"
    print -r -- "  - $launcher ${(j: :)rm_args}"
    _codex_workspace_confirm_or_abort "‚ùì Proceed? [y/N] " || return 1
  fi

  print -r -- "+ $launcher ${(j: :)rm_args}"
  "$launcher" "${rm_args[@]}"

  return $?
}

# agent-workspace-rm <name|container> [--keep-volumes] [--yes]
# agent-workspace-rm --all [--keep-volumes] [--yes]
# Remove workspace container(s) and their named volumes.
agent-workspace-rm() {
  emulate -L zsh
  setopt pipe_fail

  if (( $# == 0 )); then
    cat <<'EOF'
usage:
  agent-workspace-rm <name|container> [--keep-volumes] [--yes]
  agent-workspace-rm --all [--keep-volumes] [--yes]

Remove workspace container(s) and their named volumes.

Notes:
  - Delegates to the agent-kit launcher: <launcher> rm <container>
  - By default, volumes are removed; pass --keep-volumes to preserve them.
  - Add --yes to skip the confirmation prompt.
EOF
    return 0
  fi

  local -i want_all=0
  local -i want_yes=0
  local -i keep_volumes=0
  local -i want_help=0
  local name=''
  local -a extra_args=()

  while (( $# > 0 )); do
    case "$1" in
      -h|--help)
        want_help=1
        shift
        ;;
      --all)
        want_all=1
        shift
        ;;
      --keep-volumes)
        keep_volumes=1
        shift
        ;;
      --volumes)
        keep_volumes=0
        shift
        ;;
      -y|--yes)
        want_yes=1
        shift
        ;;
      --)
        shift
        while (( $# > 0 )); do
          if [[ -z "$name" ]]; then
            name="$1"
          else
            extra_args+=("$1")
          fi
          shift
        done
        ;;
      -*)
        print -u2 -r -- "error: unknown option: $1"
        return 2
        ;;
      *)
        if [[ -z "$name" ]]; then
          name="$1"
        else
          extra_args+=("$1")
        fi
        shift
        ;;
    esac
  done

  if (( want_help )); then
    cat <<'EOF'
usage:
  agent-workspace-rm <name|container> [--keep-volumes] [--yes]
  agent-workspace-rm --all [--keep-volumes] [--yes]

Remove workspace container(s) and their named volumes.

Notes:
  - Delegates to: <launcher> rm <container> [--keep-volumes]
  - By default, volumes are removed; pass --keep-volumes to preserve them.
  - Add --yes to skip the confirmation prompt.
EOF
    return 0
  fi

  if (( ${#extra_args[@]} > 0 )); then
    print -u2 -r -- "error: unexpected extra args: ${extra_args[*]}"
    return 2
  fi

  _codex_workspace_require_docker || return $?
  if ! docker info >/dev/null 2>&1; then
    print -u2 -r -- "error: docker daemon not running (start OrbStack/Docker Desktop)"
    return 1
  fi

  local launcher=''
  launcher="$(_codex_workspace_resolve_launcher_for_callthrough)" || return $?

  if (( want_all )); then
    if [[ -n "$name" ]]; then
      print -u2 -r -- "error: cannot combine --all with a workspace name"
      return 2
    fi

    local ls_out=''
    ls_out="$("$launcher" ls)" || return $?

    local -a containers=()
    local line=''
    for line in "${(@f)ls_out}"; do
      [[ -n "$line" ]] || continue
      containers+=("${line%%$'\t'*}")
    done
    if (( ${#containers[@]} == 0 )); then
      print -u2 -r -- "no workspaces found"
      return 0
    fi

    if (( !want_yes )); then
      print -r -- "This will REMOVE ${#containers[@]} workspace(s):"
      _codex_workspace_print_folders "${containers[@]}"
      print -r --
      if (( keep_volumes )); then
        print -r -- "Actions (per workspace): $launcher rm <container> --keep-volumes"
      else
        print -r -- "Actions (per workspace): $launcher rm <container>"
      fi
      _codex_workspace_confirm_or_abort "‚ùì Proceed? [y/N] " || return 1
    fi

    local -i rc=0
    local container=''
    for container in "${containers[@]}"; do
      _codex_workspace_rm_one "$launcher" "$container" "$keep_volumes" 1 || rc=1
    done
    return $rc
  fi

  if [[ -z "$name" ]]; then
    print -u2 -r -- "error: missing workspace name/container"
    print -u2 -r -- "hint: agent-workspace rm <name|container> [--yes]"
    return 2
  fi

  _codex_workspace_rm_one "$launcher" "$name" "$keep_volumes" "$want_yes"
  return $?
}

# --- END _features/agent-workspace/workspace-rm.zsh

# --- BEGIN _features/agent-workspace/workspace-rsync.zsh
# Host helper to rsync files between the host and a Codex workspace container (feature: agent-workspace).
#
# Usage:
#   agent-workspace rsync push [options] [<name|container>] <host_src> <container_dest> [<rsync_args...>]
#   agent-workspace rsync pull [options] [<name|container>] <container_src> <host_dest> [<rsync_args...>]
#
# Notes:
#   - The container arg is optional when only one workspace exists.
#   - Pass additional rsync flags after the src/dest paths; this wrapper will place them before the paths.
#   - Requires `rsync` on the host and inside the container.
#   - Uses `docker exec` as the rsync remote shell (no SSH needed).

# _codex_workspace_rsync_usage
# Print help for `agent-workspace rsync`.
_codex_workspace_rsync_usage() {
  emulate -L zsh

  cat <<'EOF'
usage:
  agent-workspace rsync push [--user <user>|--root] [--delete] [--dry-run] [<name|container>] <host_src> <container_dest> [<rsync_args...>]
  agent-workspace rsync pull [--user <user>|--root] [--delete] [--dry-run] [<name|container>] <container_src> <host_dest> [<rsync_args...>]

examples:
  # push ./data -> /work/data (auto-picks the only workspace)
  agent-workspace rsync push ./data/ /work/data/

  # pull /work/repo -> ./repo (explicit container)
  agent-workspace rsync pull ws-foo /work/repo/ ./repo/

  # pass rsync filters/options (placed before paths)
  agent-workspace rsync push ws-foo ./src/ /work/src/ --exclude '.git' --delete

notes:
  - Requires `rsync` on the host and inside the container.
  - Uses `docker exec` as the rsync remote shell (no SSH needed).
EOF

  return 0
}

# _codex_workspace_rsync_mktemp
# Create a temporary executable file and print its path.
_codex_workspace_rsync_mktemp() {
  emulate -L zsh

  local tmp=''
  tmp="$(mktemp "${TMPDIR:-/tmp}/agent-workspace-rsync-rsh.XXXXXX" 2>/dev/null || true)"
  if [[ -z "$tmp" ]]; then
    tmp="$(mktemp -t agent-workspace-rsync-rsh.XXXXXX 2>/dev/null || true)"
  fi
  if [[ -z "$tmp" ]]; then
    print -u2 -r -- "error: mktemp failed (rsync remote shell wrapper)"
    return 1
  fi

  print -r -- "$tmp"
  return 0
}

# agent-workspace-rsync <push|pull> [options] [<name|container>] <src> <dest> [rsync_args...]
# Sync files between the host and a workspace container using rsync-over-docker-exec.
agent-workspace-rsync() {
  emulate -L zsh
  setopt pipe_fail

  if (( $# == 0 )); then
    _codex_workspace_rsync_usage
    return 0
  fi

  local subcmd="${1:-}"
  case "$subcmd" in
    -h|--help|help)
      _codex_workspace_rsync_usage
      return 0
      ;;
    push|pull)
      shift 1 2>/dev/null || true
      ;;
    *)
      print -u2 -r -- "error: unknown rsync subcommand: $subcmd"
      print -u2 -r -- "hint: expected: push|pull"
      _codex_workspace_rsync_usage
      return 2
      ;;
  esac

  local -i want_help=0
  local -i want_delete=0
  local -i want_dry_run=0
  local -i want_root=0
  local user='codex'

  while (( $# > 0 )); do
    case "$1" in
      -h|--help)
        want_help=1
        shift
        ;;
      --delete)
        want_delete=1
        shift
        ;;
      -n|--dry-run)
        want_dry_run=1
        shift
        ;;
      --root)
        want_root=1
        shift
        ;;
      -u|--user)
        user="${2:-}"
        if [[ -z "${user//[[:space:]]/}" ]]; then
          print -u2 -r -- "error: $1 requires a value"
          return 2
        fi
        shift 2 2>/dev/null || true
        ;;
      --user=*)
        user="${1#*=}"
        if [[ -z "${user//[[:space:]]/}" ]]; then
          print -u2 -r -- "error: --user requires a value"
          return 2
        fi
        shift
        ;;
      --)
        print -u2 -r -- "error: unexpected -- (pass rsync flags after the src/dest paths)"
        return 2
        ;;
      -*)
        print -u2 -r -- "error: unknown option: $1"
        print -u2 -r -- "hint: pass rsync flags after the src/dest paths"
        return 2
        ;;
      *)
        break
        ;;
    esac
  done

  if (( want_help )); then
    _codex_workspace_rsync_usage
    return 0
  fi

  if (( want_root )); then
    user='root'
  fi

  if ! command -v rsync >/dev/null 2>&1; then
    print -u2 -r -- "error: rsync not found on host"
    return 1
  fi

  local -a rest=()
  rest=("$@")
  if (( ${#rest[@]} < 2 )); then
    print -u2 -r -- "error: missing args"
    _codex_workspace_rsync_usage
    return 2
  fi

  local container_arg='' src='' dest=''
  local -a rsync_args=()

  if (( ${#rest[@]} == 2 )); then
    container_arg=''
    src="${rest[1]}"
    dest="${rest[2]}"
    rsync_args=()
  else
    # Heuristic:
    # - If arg3 looks like an option (starts with -), treat as "no container" mode:
    #     <src> <dest> <rsync_args...>
    # - Otherwise treat as:
    #     <name|container> <src> <dest> <rsync_args...>
    if [[ "${rest[3]-}" == -* ]]; then
      container_arg=''
      src="${rest[1]}"
      dest="${rest[2]}"
      rsync_args=("${rest[@]:2}")
    else
      container_arg="${rest[1]}"
      src="${rest[2]}"
      dest="${rest[3]}"
      rsync_args=("${rest[@]:3}")
    fi
  fi

  if (( $+functions[_codex_workspace_resolve_container] )); then
    local container=''
    container="$(_codex_workspace_resolve_container "$container_arg")" || return $?

    if (( $+functions[_codex_workspace_ensure_container_running] )); then
      _codex_workspace_ensure_container_running "$container" || return $?
    fi

    if ! docker exec -u "$user" "$container" rsync --version >/dev/null 2>&1; then
      print -u2 -r -- "error: rsync not available in container: $container (user: $user)"
      print -u2 -r -- "hint: install rsync in the container image"
      return 1
    fi

    local rsh=''
    rsh="$(_codex_workspace_rsync_mktemp)" || return $?

    cat >| "$rsh" <<'EOF'
#!/bin/sh
set -eu

container="${AGENT_WORKSPACE_RSYNC_CONTAINER:?missing AGENT_WORKSPACE_RSYNC_CONTAINER}"
user="${AGENT_WORKSPACE_RSYNC_USER:-codex}"

# rsync remote-shell invocation:
#   <rsh> [opts...] <host> <command...>
# Some variants include: -l <user> <host>
while [ $# -gt 0 ]; do
  case "$1" in
    -l)
      shift 2
      ;;
    --*)
      shift
      ;;
    -*)
      shift
      ;;
    *)
      shift # host
      break
      ;;
  esac
done

exec docker exec -u "$user" -i "$container" "$@"
EOF

    chmod 700 "$rsh" 2>/dev/null || true

    local -a cmd=()
    cmd=(rsync -rlpt --partial --progress -e "$rsh")

    if (( want_delete )); then
      cmd+=(--delete)
    fi
    if (( want_dry_run )); then
      cmd+=(--dry-run)
    fi

    cmd+=("${rsync_args[@]}")

    if [[ "$subcmd" == "push" ]]; then
      cmd+=("$src" "${container}:${dest}")
    else
      cmd+=("${container}:${src}" "$dest")
    fi

    print -r -- "+ ${cmd[*]}"
    local rc=0
    AGENT_WORKSPACE_RSYNC_CONTAINER="$container" AGENT_WORKSPACE_RSYNC_USER="$user" "${cmd[@]}"
    rc=$?
    rm -f -- "$rsh" 2>/dev/null || true
    return $rc
  fi

  print -u2 -r -- "error: agent-workspace rsync requires agent-workspace feature loaded"
  return 1
}

# --- END _features/agent-workspace/workspace-rsync.zsh

# --- BEGIN _features/agent-workspace/workspace-launcher.zsh
# Host helper to start a Codex workspace container (Dev Containers mode) (feature: agent-workspace).
#
# Usage:
#   agent-workspace
#   agent-workspace create [--private-repo <owner/repo|URL>] [<owner/repo|URL>...]
#   agent-workspace auth codex [--profile <name>] [--container <name|container>]
#   agent-workspace auth github [--host <host>] [--container <name|container>]
#   agent-workspace auth gpg [--key <keyid|fingerprint>] [--container <name|container>]
#
# Example:
#   agent-workspace create OWNER/REPO
#   agent-workspace auth github
#   agent-workspace auth codex --profile work
#
# Env:
# - AGENT_WORKSPACE_PRIVATE_REPO: optional; clone/pull this repo into ~/.private inside the container.

# _codex_workspace_hex_encode_ascii <input>
# Print lowercase hex encoding of ASCII input (best-effort).
_codex_workspace_hex_encode_ascii() {
  emulate -L zsh
  setopt pipe_fail

  local input="${1-}"
  [[ -n "$input" ]] || return 1

  local -i i=0
  local out=''
  for (( i = 1; i <= ${#input}; i++ )); do
    local c="${input[i]}"
    out+="$(printf '%02x' "'$c")"
  done

  print -r -- "$out"
  return 0
}

# _codex_workspace_json_get <json> <path>
# Print a value from launcher JSON output (best-effort; prints empty string for null/missing).
_codex_workspace_json_get() {
  emulate -L zsh
  setopt pipe_fail

  local json="${1:-}"
  local json_path="${2:-}"
  [[ -n "$json" && -n "$json_path" ]] || return 1

  if command -v python3 >/dev/null 2>&1; then
    python3 - "$json_path" "$json" <<'PY'
import json
import sys

path = sys.argv[1].lstrip(".")
raw = sys.argv[2]
try:
  data = json.loads(raw)
except Exception:
  sys.exit(2)

cursor = data
for part in path.split("."):
  if not part:
    continue
  if isinstance(cursor, dict):
    cursor = cursor.get(part)
  else:
    cursor = None
  if cursor is None:
    break

if cursor is None:
  sys.exit(0)

if isinstance(cursor, bool):
  sys.stdout.write("true" if cursor else "false")
else:
  sys.stdout.write(str(cursor))
PY
    return $?
  fi

  if command -v jq >/dev/null 2>&1; then
    local query="$json_path"
    [[ "$query" == .* ]] || query=".$query"
    local out=''
    out="$(print -r -- "$json" | jq -r --exit-status "${query} // empty" 2>/dev/null)" || return 1
    print -r -- "$out"
    return 0
  fi

  print -u2 -r -- "error: missing JSON parser (need python3 or jq) to consume launcher --output json"
  return 1
}

# _codex_workspace_repo_default_from_cwd
# Print a best-effort repo URL from the current git worktree (origin preferred).
_codex_workspace_repo_default_from_cwd() {
  emulate -L zsh
  setopt pipe_fail

  command -v git >/dev/null 2>&1 || return 1
  git rev-parse --is-inside-work-tree >/dev/null 2>&1 || return 1

  local url=''
  url="$(git remote get-url origin 2>/dev/null || true)"
  if [[ -n "$url" ]]; then
    print -r -- "$url"
    return 0
  fi

  local -a remotes=()
  remotes=(${(f)"$(git remote 2>/dev/null || true)"})
  local remote=''
  for remote in "${remotes[@]}"; do
    url="$(git remote get-url "$remote" 2>/dev/null || true)"
    [[ -n "$url" ]] || continue
    print -r -- "$url"
    return 0
  done

  return 1
}

# _codex_workspace_usage
# Print CLI usage/help for `agent-workspace`.
_codex_workspace_usage() {
  emulate -L zsh

  cat <<'EOF'
usage:
  agent-workspace
  agent-workspace auth <provider> [options] [<name|container>]
  agent-workspace ls
  agent-workspace start [<name|container>]
  agent-workspace stop [<name|container>]
  agent-workspace create [--no-extras] [--codex-profile <name>] [--private-repo <owner/repo|URL>] [--gpg|--no-gpg] [--gpg-key <keyid|fingerprint>] [<owner/repo|URL>...]
  agent-workspace create --no-work-repos --name <name> [--no-extras] [--codex-profile <name>] [--private-repo <owner/repo|URL>]
  agent-workspace exec [--root] [--user <user>] <name|container> [--] [cmd...]
  agent-workspace rsync <push|pull> [options] [<name|container>] <src> <dest> [rsync_args...]
  agent-workspace rm <name|container> [--yes]
  agent-workspace rm --all [--yes]
  agent-workspace reset repo <name|container> <repo_dir> [--ref <remote/branch>] [--yes]
  agent-workspace reset work-repos <name|container> [--root <dir>] [--depth <N>] [--ref <remote/branch>] [--yes]
  agent-workspace reset opt-repos <name|container> [--yes]
  agent-workspace reset private-repo <name|container> [--ref <remote/branch>] [--yes]
  agent-workspace tunnel <container> [--name <tunnel_name>] [--detach]

example:
  agent-workspace create OWNER/REPO
  agent-workspace create OWNER/REPO OTHER/REPO  # clones in order
  agent-workspace create                        # uses current git remote (origin)
  agent-workspace create --no-extras OWNER/REPO  # skip cloning ~/.private and extra repos
  agent-workspace create --codex-profile work OWNER/REPO
  agent-workspace create --gpg OWNER/REPO        # import host gpg signing key into container
  agent-workspace create --no-work-repos --name ws-foo
  agent-workspace create --no-work-repos --name ws-foo --private-repo OWNER/PRIVATE_REPO
  agent-workspace create --private-repo OWNER/PRIVATE_REPO OWNER/REPO
  AGENT_WORKSPACE_PRIVATE_REPO=OWNER/PRIVATE_REPO agent-workspace create OWNER/REPO
  agent-workspace auth github
  agent-workspace auth codex --profile work
  agent-workspace auth gpg --key <fingerprint>
  agent-workspace ls
  agent-workspace start ws-foo
  agent-workspace stop ws-foo
  agent-workspace exec ws-foo
  agent-workspace rsync push ws-foo ./src/ /work/src/
  agent-workspace reset work-repos ws-foo --yes
  agent-workspace reset opt-repos ws-foo --yes
  agent-workspace reset private-repo ws-foo --yes
  agent-workspace rm --all

notes:
  - `agent-workspace` prints help; use `agent-workspace create ...` to start a workspace.
  - Repo args are optional when inside a git repo (defaults to `git remote get-url origin`),
    unless `--no-work-repos` is used.
  - Use `--no-extras` to disable cloning `~/.private` and additional repos under `/work`.
  - Use `--no-work-repos` to create a workspace without cloning any repos into `/work`
    (including the default-from-CWD `origin`); requires `--name` and rejects repo args.
  - If the agent-kit launcher script is missing, this function auto-downloads it from GitHub.
    - Disable auto-download with: AGENT_WORKSPACE_LAUNCHER_AUTO_DOWNLOAD=false
    - Override the source with: AGENT_WORKSPACE_LAUNCHER_URL=<url>
    - Override the install path with: AGENT_WORKSPACE_LAUNCHER_AUTO_PATH=<path>
    - Or set an explicit launcher with: AGENT_WORKSPACE_LAUNCHER=<path>
  - Auth is automatic by default:
    - If `gh` is logged in (keyring), this function prefers that token (works better across orgs).
    - Otherwise it falls back to host GH_TOKEN/GITHUB_TOKEN.
    - Override with: AGENT_WORKSPACE_AUTH=env|gh|auto|none
  - GPG signing is opt-in (imports host secret key into container):
    - Enable on create: `--gpg` (optionally `--gpg-key ...`)
    - Or re-apply later: `agent-workspace auth gpg`
    - Configure defaults via: AGENT_WORKSPACE_GPG=import|none and AGENT_WORKSPACE_GPG_KEY=<key>
  - Codex profiles can be set on create with AGENT_WORKSPACE_AGENT_PROFILE or --codex-profile <name>.
  - Use `agent-workspace auth codex|github|gpg` to re-apply auth to an existing workspace.
  - If org SSO blocks access, run: `env -u GH_TOKEN -u GITHUB_TOKEN gh auth refresh -h github.com -s repo -s read:org`
  - VS Code: if you see "cannot find workspace /work/..." you likely attached from an existing window;
    open a new window, or run the printed `code --new-window --folder-uri ...` command.
  - To auto-open VS Code after launch: `AGENT_WORKSPACE_OPEN_VSCODE_ENABLED=true agent-workspace create OWNER/REPO`
  - On each workspace creation, it refreshes `/opt/agent-kit` + `/opt/zsh-kit` in the container.
  - This function snapshots host ~/.config into the container (copy, not bind-mount),
    excluding ~/.config/agent-kit and ~/.config/zsh to avoid conflicts.
  - Host codex secrets (~/.config/AGENT_secrets) are bind-mounted read-write to ~/AGENT_secrets.
  - Optional: to seed container ~/.private from a dedicated repo, set:
      - AGENT_WORKSPACE_PRIVATE_REPO=OWNER/REPO (or URL)
      - or pass: --private-repo OWNER/REPO (or URL)
  - VS Code: Cmd+Shift+P -> "Dev Containers: Attach to Running Container..."
EOF

  return 0
}

# _codex_workspace_default_gpg_signing_key
# Return a best-effort host signing key to import (prefers explicit env var).
_codex_workspace_default_gpg_signing_key() {
  emulate -L zsh
  setopt pipe_fail

  local key="${AGENT_WORKSPACE_GPG_KEY-}"
  key="${key%%[[:space:]]#}"
  if [[ -n "$key" ]]; then
    print -r -- "$key"
    return 0
  fi

  if command -v git >/dev/null 2>&1; then
    key="$(git config --global --get user.signingkey 2>/dev/null || true)"
    key="${key%%[[:space:]]#}"
    if [[ -n "$key" ]]; then
      print -r -- "$key"
      return 0
    fi
  fi

  return 1
}

# _codex_workspace_auth_gpg <container> [key]
# Import the host GPG secret key into the workspace container (so `git commit -S` works).
_codex_workspace_auth_gpg() {
  emulate -L zsh
  setopt pipe_fail

  local container="${1:?missing container}"
  local key="${2-}"

  if [[ -z "${key//[[:space:]]/}" ]]; then
    key="$(_codex_workspace_default_gpg_signing_key 2>/dev/null || true)"
  fi

  if [[ -z "${key//[[:space:]]/}" ]]; then
    print -u2 -r -- "error: missing gpg signing key"
    print -u2 -r -- "hint: pass --key <fingerprint> or set AGENT_WORKSPACE_GPG_KEY"
    print -u2 -r -- "hint: or set: git config --global user.signingkey <keyid>"
    return 1
  fi

  if ! command -v gpg >/dev/null 2>&1; then
    print -u2 -r -- "error: gpg not found on host (required to export secret key)"
    print -u2 -r -- "hint: install gnupg (brew install gnupg)"
    return 1
  fi

  _codex_workspace_ensure_container_running "$container" || return $?

  print -r -- "auth: gpg -> $container (key=$key)"

  # Export on host, import into container. Avoid writing key material to disk.
  if ! gpg --batch --armor --export-secret-keys -- "$key" \
    | docker exec -i -u codex "$container" bash -c '
      set -euo pipefail
      if ! command -v gpg >/dev/null 2>&1; then
        echo "error: gpg not installed in container" >&2
        exit 127
      fi
      umask 077
      mkdir -p "$HOME/.gnupg"
      chmod 700 "$HOME/.gnupg" 2>/dev/null || true
      gpg --batch --import >/dev/null 2>&1
    '; then
    print -u2 -r -- "error: failed to import gpg secret key into $container"
    print -u2 -r -- "hint: verify the host key exists: gpg --list-secret-keys -- '$key'"
    return 1
  fi

  # Best-effort verification (quiet).
  docker exec -u codex "$container" bash -lc 'gpg --list-secret-keys --keyid-format LONG -- "$1" >/dev/null 2>&1' -- "$key" || {
    print -u2 -r -- "warn: gpg import completed but key lookup failed in container (key=$key)"
  }

  return 0
}

# _codex_workspace_parse_repo_spec <input> [default_host]
# Parse a repo spec (OWNER/REPO or URL) into host/owner/repo and https clone URL.
_codex_workspace_parse_repo_spec() {
  emulate -L zsh
  setopt pipe_fail

  local input="${1:-}"
  local default_host="${2:-github.com}"
  [[ -n "$input" ]] || return 1

  local host="$default_host"
  local owner_repo="$input"

  if [[ "$input" == http://* || "$input" == https://* ]]; then
    local without_scheme="${input#*://}"
    host="${without_scheme%%/*}"
    owner_repo="${without_scheme#*/}"
  elif [[ "$input" == git@*:* ]]; then
    local without_user="${input#git@}"
    host="${without_user%%:*}"
    owner_repo="${input#*:}"
  elif [[ "$input" == ssh://git@*/* ]]; then
    local without_prefix="${input#ssh://git@}"
    host="${without_prefix%%/*}"
    owner_repo="${without_prefix#*/}"
  fi

  owner_repo="${owner_repo%.git}"
  owner_repo="${owner_repo%/}"
  if [[ "$owner_repo" == */*/* ]]; then
    local owner="${owner_repo%%/*}"
    local rest="${owner_repo#*/}"
    local name="${rest%%/*}"
    owner_repo="${owner}/${name}"
  fi
  [[ "$owner_repo" == */* ]] || return 1

  local owner="${owner_repo%%/*}"
  local repo="${owner_repo##*/}"
  local clone_url="https://${host}/${owner}/${repo}.git"

  reply=("$host" "$owner" "$repo" "$owner_repo" "$clone_url")
  return 0
}

# _codex_workspace_launcher_default_path
# Return the default agent-kit launcher path on the host.
_codex_workspace_launcher_default_path() {
  emulate -L zsh

  local primary="$HOME/.codex/docker/agent-env/bin/agent-workspace"
  if [[ -x "$primary" ]]; then
    print -r -- "$primary"
    return 0
  fi

  print -r -- "$HOME/.config/agent-kit/docker/agent-env/bin/agent-workspace"
  return 0
}

# _codex_workspace_launcher_auto_path
# Return the auto-install path for the launcher under XDG cache.
_codex_workspace_launcher_auto_path() {
  emulate -L zsh

  local cache_root="${XDG_CACHE_HOME:-$HOME/.cache}"
  cache_root="${cache_root%/}"
  print -r -- "$cache_root/agent-workspace/launcher/agent-workspace"
  return 0
}

# _codex_workspace_launcher_normalize_url <url>
# Normalize GitHub "blob" URLs to raw URLs for direct downloads.
_codex_workspace_launcher_normalize_url() {
  emulate -L zsh

  local url="${1:-}"
  [[ -n "$url" ]] || return 1

  # Convert GitHub "blob" URLs to raw URLs for direct downloads.
  if [[ "$url" == https://github.com/*/*/blob/* ]]; then
    local without_prefix="${url#https://github.com/}"
    local owner="${without_prefix%%/*}"
    local rest="${without_prefix#*/}"
    local repo="${rest%%/*}"
    rest="${rest#*/}"
    rest="${rest#blob/}"
    local ref="${rest%%/*}"
    local path="${rest#*/}"
    url="https://raw.githubusercontent.com/${owner}/${repo}/${ref}/${path}"
  fi

  print -r -- "$url"
  return 0
}

# _codex_workspace_ensure_launcher <launcher> <explicit>
# Return an executable launcher path; auto-download when missing and not explicit.
_codex_workspace_ensure_launcher() {
  emulate -L zsh
  setopt pipe_fail

  local launcher="${1:-}"
  local -i explicit="${2:-0}"

  [[ -n "$launcher" ]] || return 1

  if [[ -x "$launcher" ]]; then
    print -r -- "$launcher"
    return 0
  fi

  if (( explicit )); then
    print -u2 -r -- "error: launcher not found or not executable: $launcher"
    return 1
  fi

  local auto_download="${AGENT_WORKSPACE_LAUNCHER_AUTO_DOWNLOAD:-true}"
  case "$auto_download" in
    true|"")
      ;;
    false)
      print -u2 -r -- "error: launcher not found: $launcher"
      print -u2 -r -- "hint: auto-download disabled (set AGENT_WORKSPACE_LAUNCHER_AUTO_DOWNLOAD=true to enable)"
      return 1
      ;;
    *)
      print -u2 -r -- "error: AGENT_WORKSPACE_LAUNCHER_AUTO_DOWNLOAD must be true or false (got: $auto_download)"
      return 1
      ;;
  esac

  local auto_path="${AGENT_WORKSPACE_LAUNCHER_AUTO_PATH:-$(_codex_workspace_launcher_auto_path)}"
  if [[ -x "$auto_path" ]]; then
    print -r -- "$auto_path"
    return 0
  fi

  local url_default="https://raw.githubusercontent.com/graysurf/agent-kit/main/docker/agent-env/bin/agent-workspace"
  local url="${AGENT_WORKSPACE_LAUNCHER_URL:-$url_default}"
  url="$(_codex_workspace_launcher_normalize_url "$url" 2>/dev/null || print -r -- "$url")"
  if [[ "$url" != https://* ]]; then
    print -u2 -r -- "error: launcher download URL must be https:// (got: $url)"
    return 1
  fi

  local auto_dir="${auto_path%/*}"
  command mkdir -p -- "$auto_dir" 2>/dev/null || {
    print -u2 -r -- "error: failed to create launcher dir: $auto_dir"
    return 1
  }

  local tmp=''
  tmp="$(mktemp "${TMPDIR:-/tmp}/agent-workspace-launcher.XXXXXX" 2>/dev/null || true)"
  if [[ -z "$tmp" ]]; then
    tmp="$(mktemp -t agent-workspace-launcher.XXXXXX 2>/dev/null || true)"
  fi
  if [[ -z "$tmp" ]]; then
    print -u2 -r -- "error: mktemp failed (launcher download)"
    return 1
  fi

  print -u2 -r -- "info: downloading launcher: $url"
  if command -v curl >/dev/null 2>&1; then
    command curl -fsSL "$url" >| "$tmp" || {
      rm -f -- "$tmp" 2>/dev/null || true
      print -u2 -r -- "error: failed to download launcher via curl"
      return 1
    }
  elif command -v wget >/dev/null 2>&1; then
    command wget -qO "$tmp" "$url" || {
      rm -f -- "$tmp" 2>/dev/null || true
      print -u2 -r -- "error: failed to download launcher via wget"
      return 1
    }
  else
    rm -f -- "$tmp" 2>/dev/null || true
    print -u2 -r -- "error: missing downloader (need: curl or wget)"
    return 1
  fi

  if [[ ! -s "$tmp" ]]; then
    rm -f -- "$tmp" 2>/dev/null || true
    print -u2 -r -- "error: launcher download returned empty file"
    return 1
  fi

  command chmod 700 "$tmp" 2>/dev/null || true
  command mv -f -- "$tmp" "$auto_path" || {
    rm -f -- "$tmp" 2>/dev/null || true
    print -u2 -r -- "error: failed to install launcher to: $auto_path"
    return 1
  }

  print -u2 -r -- "info: installed launcher: $auto_path"
  print -r -- "$auto_path"
  return 0
}

# _codex_workspace_resolve_container [name|container]
# Resolve a workspace container name (auto-picks when only one exists).
_codex_workspace_resolve_container() {
  emulate -L zsh
  setopt pipe_fail

  local name="${1:-}"

  _codex_workspace_require_docker || return $?
  if ! docker info >/dev/null 2>&1; then
    print -u2 -r -- "error: docker daemon not running (start OrbStack/Docker Desktop)"
    return 1
  fi

  if [[ -n "$name" ]]; then
    local container=''
    container="$(_codex_workspace_normalize_container_name "$name")" || return 1
    _codex_workspace_require_container "$container" || return $?
    print -r -- "$container"
    return 0
  fi

  local -a containers=()
  containers=("${(@f)$(_codex_workspace_container_names)}")
  if (( ${#containers[@]} == 1 )); then
    print -r -- "${containers[1]}"
    return 0
  fi

  if (( ${#containers[@]} == 0 )); then
    print -u2 -r -- "error: no workspaces found"
  else
    print -u2 -r -- "error: multiple workspaces found; specify one:"
    _codex_workspace_print_folders "${containers[@]}"
  fi
  return 2
}

# _codex_workspace_ensure_container_running <container>
# Ensure the workspace container is running (starts it when stopped).
_codex_workspace_ensure_container_running() {
  emulate -L zsh

  local container="${1:-}"
  [[ -n "$container" ]] || return 1

  local running=''
  running="$(docker inspect -f '{{.State.Running}}' "$container" 2>/dev/null || true)"
  if [[ "$running" != "true" ]]; then
    print -r -- "info: starting workspace: $container"
    docker start "$container" >/dev/null || {
      print -u2 -r -- "error: failed to start workspace: $container"
      return 1
    }
  fi

  return 0
}

# _codex_workspace_require_codex_use
# Ensure codex-use is available on the host.
_codex_workspace_require_codex_use() {
  emulate -L zsh
  setopt pipe_fail

  if typeset -f codex-use >/dev/null 2>&1; then
    return 0
  fi

  local source_file_path=''
  if [[ -f "$HOME/.config/AGENT_secrets/codex-secret.zsh" ]]; then
    source_file_path="$HOME/.config/AGENT_secrets/codex-secret.zsh"
  elif [[ -n "${ZSH_SCRIPT_DIR-}" && -f "${ZSH_SCRIPT_DIR}/_features/codex/codex-secret.zsh" ]]; then
    source_file_path="${ZSH_SCRIPT_DIR}/_features/codex/codex-secret.zsh"
  fi

  if [[ -n "$source_file_path" ]]; then
    if (( $+functions[source_file] )); then
      source_file "$source_file_path"
    else
      source "$source_file_path"
    fi
  fi

  typeset -f codex-use >/dev/null 2>&1
}

# _codex_workspace_auth_github <container> [host]
# Apply GitHub auth to an existing workspace container.
_codex_workspace_auth_github() {
  emulate -L zsh
  setopt pipe_fail

  local container="${1:?missing container}"
  local gh_host="${2:-${GITHUB_HOST:-github.com}}"

  local auth_mode="${AGENT_WORKSPACE_AUTH:-auto}"
  local env_token="${GH_TOKEN:-${GITHUB_TOKEN:-}}"
  local keyring_token=''
  if command -v gh >/dev/null 2>&1; then
    keyring_token="$(env -u GH_TOKEN -u GITHUB_TOKEN gh auth token -h "$gh_host" 2>/dev/null || true)"
  fi

  local chosen_token='' chosen_source=''
  case "$auth_mode" in
    none)
      chosen_source="none"
      ;;
    env)
      chosen_token="$env_token"
      chosen_source="env"
      ;;
    gh|keyring)
      if [[ -n "$keyring_token" ]]; then
        chosen_token="$keyring_token"
        chosen_source="gh"
      else
        print -u2 -r -- "warn: AGENT_WORKSPACE_AUTH=gh but no gh keyring token found; falling back to GH_TOKEN/GITHUB_TOKEN"
        chosen_token="$env_token"
        chosen_source="env"
      fi
      ;;
    auto|"")
      if [[ -n "$keyring_token" ]]; then
        chosen_token="$keyring_token"
        chosen_source="gh"
      else
        chosen_token="$env_token"
        chosen_source="env"
      fi
      ;;
    *)
      print -u2 -r -- "error: unknown AGENT_WORKSPACE_AUTH=$auth_mode (expected: auto|gh|env|none)"
      return 2
      ;;
  esac

  if [[ -z "$chosen_token" ]]; then
    if [[ "$auth_mode" == "none" ]]; then
      print -u2 -r -- "error: AGENT_WORKSPACE_AUTH=none; no token to apply"
    else
      print -u2 -r -- "error: no GitHub token found (gh keyring or GH_TOKEN/GITHUB_TOKEN)"
    fi
    print -u2 -r -- "hint: run 'gh auth login' or export GH_TOKEN/GITHUB_TOKEN"
    return 1
  fi

  _codex_workspace_ensure_container_running "$container" || return $?

  print -r -- "auth: github -> $container ($gh_host; source=$chosen_source)"
  # Use a non-login shell (`bash -c`) to avoid login logout hooks (e.g. bash_logout)
  # turning a successful auth update into a non-zero exit status.
  if ! print -r -- "$chosen_token" | docker exec -i -u codex "$container" bash -c '
    set -euo pipefail
    host="${1:-github.com}"
    IFS= read -r token || exit 2
    [[ -n "$token" ]] || exit 2

    if command -v gh >/dev/null 2>&1; then
      printf "%s\n" "$token" | gh auth login --hostname "$host" --with-token >/dev/null 2>&1 || true
      gh auth setup-git --hostname "$host" --force >/dev/null 2>&1 || gh auth setup-git --hostname "$host" >/dev/null 2>&1 || true
      gh config set git_protocol https -h "$host" 2>/dev/null || gh config set git_protocol https 2>/dev/null || true
      exit 0
    fi

    if command -v git >/dev/null 2>&1; then
      token_file="$HOME/.agents-env/gh.token"
      mkdir -p "${token_file%/*}"
      printf "%s\n" "$token" >| "$token_file"
      chmod 600 "$token_file" 2>/dev/null || true
      git config --global "credential.https://${host}.helper" \
        "!f() { echo username=x-access-token; echo password=\$(cat \"$token_file\"); }; f"
    fi
  ' -- "$gh_host"; then
    print -u2 -r -- "error: failed to update GitHub auth in $container"
    return 1
  fi

  if [[ "$chosen_source" == "gh" || "$chosen_source" == "env" ]]; then
    typeset -g AGENT_WORKSPACE_AUTH="$chosen_source"
  fi

  return 0
}

# _codex_workspace_auth_codex <container> [profile]
# Apply Codex auth to an existing workspace container.
_codex_workspace_auth_codex() {
  emulate -L zsh
  setopt pipe_fail

  local container="${1:?missing container}"
  local profile="${2-}"

  if [[ -z "$profile" ]]; then
    profile="${AGENT_WORKSPACE_AGENT_PROFILE:-}"
  fi

  if [[ -n "$profile" ]]; then
    if [[ "$profile" == *'/'* || "$profile" == *'..'* || "$profile" == *[[:space:]]* ]]; then
      print -u2 -r -- "error: invalid codex profile name: $profile"
      return 2
    fi

    typeset -g AGENT_WORKSPACE_AGENT_PROFILE="$profile"
    if _codex_workspace_require_codex_use; then
      codex-use "$profile" || {
        print -u2 -r -- "warn: failed to update host codex auth (codex-use $profile)"
      }
    else
      print -u2 -r -- "warn: codex-use not available on host; skipping host auth update"
    fi

    _codex_workspace_ensure_container_running "$container" || return $?

    if ! docker exec -u codex "$container" zsh -lc '
      profile="${1:?missing profile}"
      if ! typeset -f codex-use >/dev/null 2>&1; then
        if [[ -f /opt/zsh-kit/scripts/_features/codex/codex-secret.zsh ]]; then
          source /opt/zsh-kit/scripts/_features/codex/codex-secret.zsh
        fi
      fi
      codex-use "$profile"
    ' -- "$profile" >/dev/null 2>&1; then
      print -u2 -r -- "error: failed to apply codex profile in $container"
      print -u2 -r -- "hint: ensure codex secrets are mounted (recreate without --no-secrets)"
      return 1
    fi

    print -r -- "auth: codex -> $container (profile=$profile)"
    return 0
  fi

  local auth_file="${CODEX_AUTH_FILE:-$HOME/.codex/auth.json}"
  if [[ ! -f "$auth_file" ]]; then
    print -u2 -r -- "error: codex auth file not found: $auth_file"
    print -u2 -r -- "hint: set AGENT_WORKSPACE_AGENT_PROFILE or run codex-use <profile> first"
    return 1
  fi

  _codex_workspace_ensure_container_running "$container" || return $?
  if ! command cat -- "$auth_file" | docker exec -i -u codex "$container" bash -c '
    set -euo pipefail
    target="${CODEX_AUTH_FILE:-$HOME/.codex/auth.json}"
    [[ -n "$target" ]] || target="$HOME/.codex/auth.json"
    mkdir -p "$(dirname "$target")"
    rm -f -- "$target"
    umask 077
    cat > "$target"
  '; then
    print -u2 -r -- "error: failed to sync codex auth into $container"
    print -u2 -r -- "hint: check CODEX_AUTH_FILE inside the container and ensure it is writable by user 'codex'"
    return 1
  fi
  print -r -- "auth: codex -> $container (synced auth file)"
  return 0
}

# agent-workspace-auth <provider> [options] [<name|container>]
# Update auth for an existing workspace container.
agent-workspace-auth() {
  emulate -L zsh
  setopt pipe_fail

  local provider="${1:-}"
  shift 2>/dev/null || true

  local container_arg=''
  local profile=''
  local gh_host=''
  local key=''
  local -i want_help=0

  while (( $# > 0 )); do
    case "$1" in
      -h|--help)
        want_help=1
        shift
        ;;
      --container)
        container_arg="${2-}"
        shift 2 2>/dev/null || true
        ;;
      --container=*)
        container_arg="${1#*=}"
        shift
        ;;
      --name)
        container_arg="${2-}"
        shift 2 2>/dev/null || true
        ;;
      --name=*)
        container_arg="${1#*=}"
        shift
        ;;
      --profile)
        profile="${2-}"
        shift 2 2>/dev/null || true
        ;;
      --profile=*)
        profile="${1#*=}"
        shift
        ;;
      --host)
        gh_host="${2-}"
        shift 2 2>/dev/null || true
        ;;
      --host=*)
        gh_host="${1#*=}"
        shift
        ;;
      --key)
        key="${2-}"
        shift 2 2>/dev/null || true
        ;;
      --key=*)
        key="${1#*=}"
        shift
        ;;
      --)
        shift
        break
        ;;
      -*)
        print -u2 -r -- "error: unknown option: $1"
        return 2
        ;;
      *)
        if [[ -z "$container_arg" ]]; then
          container_arg="$1"
          shift
        else
          print -u2 -r -- "error: unexpected arg: $1"
          return 2
        fi
        ;;
    esac
  done

  if [[ -z "$provider" || "$provider" == "-h" || "$provider" == "--help" || $want_help -eq 1 ]]; then
    cat <<'EOF'
usage:
  agent-workspace auth codex [--profile <name>] [--container <name|container>]
  agent-workspace auth github [--host <host>] [--container <name|container>]
  agent-workspace auth gpg [--key <keyid|fingerprint>] [--container <name|container>]

notes:
  - GitHub auth uses AGENT_WORKSPACE_AUTH (auto|gh|env|none) and host gh keyring or GH_TOKEN.
  - Codex auth uses AGENT_WORKSPACE_AGENT_PROFILE when set; otherwise syncs CODEX_AUTH_FILE.
  - GPG auth exports the host secret key and imports it into the container.
EOF
    return 0
  fi

  local container=''
  container="$(_codex_workspace_resolve_container "$container_arg")" || return $?

  case "$provider" in
    codex)
      _codex_workspace_auth_codex "$container" "$profile"
      return $?
      ;;
    github)
      _codex_workspace_auth_github "$container" "$gh_host"
      return $?
      ;;
    gpg)
      _codex_workspace_auth_gpg "$container" "$key"
      return $?
      ;;
    *)
      print -u2 -r -- "error: unknown auth provider: $provider"
      print -u2 -r -- "hint: expected: codex|github|gpg"
      return 2
      ;;
  esac
}

# agent-workspace-exec [--root] [--user <user>] <name|container> [--] [cmd...]
# Exec into a workspace container (default: zsh).
agent-workspace-exec() {
  emulate -L zsh
  setopt pipe_fail

  if (( $# == 0 )); then
    cat <<'EOF'
usage: agent-workspace exec [--root] [--user <user>] <name|container> [--] [cmd...]

Exec into a workspace container (default: zsh).

Notes:
  - Options must appear before the container name.
  - Uses `docker exec -it` when stdin+stdout are TTYs; otherwise uses `-i`.
EOF
    return 0
  fi

  local -i want_help=0
  local -i want_root=0
  local user='codex'

  while (( $# > 0 )); do
    case "$1" in
      -h|--help)
        want_help=1
        shift
        ;;
      --root)
        want_root=1
        shift
        ;;
      -u|--user)
        user="${2:-}"
        if [[ -z "${user//[[:space:]]/}" ]]; then
          print -u2 -r -- "error: $1 requires a value"
          return 2
        fi
        shift 2 2>/dev/null || true
        ;;
      --user=*)
        user="${1#*=}"
        if [[ -z "${user//[[:space:]]/}" ]]; then
          print -u2 -r -- "error: --user requires a value"
          return 2
        fi
        shift
        ;;
      --)
        shift
        break
        ;;
      -*)
        print -u2 -r -- "error: unknown option: $1"
        return 2
        ;;
      *)
        break
        ;;
    esac
  done

  if (( want_help )); then
    cat <<'EOF'
usage: agent-workspace exec [--root] [--user <user>] <name|container> [--] [cmd...]

Exec into a workspace container (default: zsh).

Notes:
  - Options must appear before the container name.
  - Uses `docker exec -it` when stdin+stdout are TTYs; otherwise uses `-i`.
EOF
    return 0
  fi

  local name="${1:-}"
  if [[ -z "$name" ]]; then
    print -u2 -r -- "error: missing workspace name/container"
    print -u2 -r -- "hint: agent-workspace exec <container>"
    return 2
  fi
  shift 1 2>/dev/null || true

  local -a cmd=()
  cmd=("$@")
  if (( ${#cmd[@]} == 0 )); then
    cmd=(zsh)
  fi

  if (( want_root )); then
    user='root'
  fi

  _codex_workspace_require_docker || return $?
  if ! docker info >/dev/null 2>&1; then
    print -u2 -r -- "error: docker daemon not running (start OrbStack/Docker Desktop)"
    return 1
  fi

  local container=''
  container="$(_codex_workspace_normalize_container_name "$name")" || return 1
  _codex_workspace_require_container "$container" || return $?

  local container_status=''
  container_status="$(docker inspect -f '{{.State.Status}}' "$container" 2>/dev/null || true)"
  if [[ "$container_status" != "running" ]]; then
    print -r -- "+ docker start $container"
    docker start "$container" >/dev/null || return 1
  fi

  local -a docker_exec=()
  docker_exec=(exec -u "$user")
  if [[ -t 0 && -t 1 ]]; then
    docker_exec+=(-it)
  elif [[ -t 0 ]]; then
    docker_exec+=(-i)
  fi

  docker_exec+=("$container")
  docker_exec+=("${cmd[@]}")

  command docker "${docker_exec[@]}"
}

# agent-workspace-tunnel [--name <tunnel_name>] [--detach] <name|container>
# Start a VS Code tunnel inside a workspace container.
agent-workspace-tunnel() {
  emulate -L zsh
  setopt pipe_fail

  if (( $# == 0 )); then
    cat <<'EOF'
usage: agent-workspace-tunnel [--name <tunnel_name>] [--detach] <name|container>

Start a VS Code tunnel inside a workspace container.

Notes:
  - Delegates to the agent-kit launcher: <launcher> tunnel <container> ...
  - VS Code tunnel names are limited to 20 characters.
  - Override the name with --name or AGENT_WORKSPACE_TUNNEL_NAME.
  - Options may appear before or after the container name.
EOF
    return 0
  fi

  local name=''
  local detach=0
  local tunnel_name="${AGENT_WORKSPACE_TUNNEL_NAME:-}"
  local -a extra_args=()
  local -i want_help=0
  while (( $# > 0 )); do
    case "$1" in
      -h|--help)
        want_help=1
        shift
        ;;
      --detach)
        detach=1
        shift
        ;;
      --name)
        tunnel_name="${2:-}"
        if [[ -z "$tunnel_name" ]]; then
          print -u2 -r -- "error: --name requires a value"
          return 2
        fi
        shift 2 2>/dev/null || true
        ;;
      --name=*)
        tunnel_name="${1#*=}"
        if [[ -z "$tunnel_name" ]]; then
          print -u2 -r -- "error: --name requires a value"
          return 2
        fi
        shift
        ;;
      --)
        shift
        while (( $# > 0 )); do
          extra_args+=("$1")
          shift
        done
        ;;
      -*)
        print -u2 -r -- "error: unknown option: $1"
        return 2
        ;;
      *)
        if [[ -z "$name" ]]; then
          name="$1"
        else
          extra_args+=("$1")
        fi
        shift
        ;;
    esac
  done

  if (( want_help )); then
    cat <<'EOF'
usage: agent-workspace-tunnel [--name <tunnel_name>] [--detach] <name|container>

Start a VS Code tunnel inside a workspace container.

Notes:
  - Delegates to the agent-kit launcher: <launcher> tunnel <container> ...
  - VS Code tunnel names are limited to 20 characters.
  - Override the name with --name or AGENT_WORKSPACE_TUNNEL_NAME.
  - Options may appear before or after the container name.
EOF
    return 0
  fi

  if [[ -z "$name" ]]; then
    print -u2 -r -- "error: missing workspace name/container"
    print -u2 -r -- "hint: agent-workspace tunnel <container> [--detach]"
    return 2
  fi

  if (( ${#extra_args[@]} > 0 )); then
    print -u2 -r -- "error: unexpected extra args: ${extra_args[*]}"
    return 2
  fi

  local container=''
  container="$(_codex_workspace_resolve_container "$name")" || return $?

  local launcher=''
  launcher="$(_codex_workspace_resolve_launcher_for_callthrough)" || return $?

  local -a tunnel_args=(tunnel "$container")
  if [[ -n "$tunnel_name" ]]; then
    tunnel_args+=(--name "$tunnel_name")
  fi
  if (( detach )); then
    tunnel_args+=(--detach)
  fi

  print -r -- "+ $launcher ${(j: :)tunnel_args}"
  "$launcher" "${tunnel_args[@]}"
  return $?
}

# agent-workspace-start [<name|container>]
# Start a workspace container (delegates to the agent-kit launcher).
agent-workspace-start() {
  emulate -L zsh
  setopt pipe_fail

  if (( $# > 1 )); then
    print -u2 -r -- "error: unexpected args: $*"
    return 2
  fi

  local arg1="${1:-}"
  if [[ "$arg1" == "-h" || "$arg1" == "--help" ]]; then
    cat <<'EOF'
usage: agent-workspace start [<name|container>]

Start a workspace container.

Notes:
  - Delegates to the agent-kit launcher: <launcher> start <container>
  - When <name|container> is omitted, auto-picks only when exactly one workspace exists.
EOF
    return 0
  fi

  local container=''
  container="$(_codex_workspace_resolve_container "$arg1")" || return $?

  local launcher=''
  launcher="$(_codex_workspace_resolve_launcher_for_callthrough)" || return $?

  print -r -- "+ $launcher start $container"
  "$launcher" start "$container"
  return $?
}

# agent-workspace-stop [<name|container>]
# Stop a workspace container (delegates to the agent-kit launcher).
agent-workspace-stop() {
  emulate -L zsh
  setopt pipe_fail

  if (( $# > 1 )); then
    print -u2 -r -- "error: unexpected args: $*"
    return 2
  fi

  local arg1="${1:-}"
  if [[ "$arg1" == "-h" || "$arg1" == "--help" ]]; then
    cat <<'EOF'
usage: agent-workspace stop [<name|container>]

Stop a workspace container.

Notes:
  - Delegates to the agent-kit launcher: <launcher> stop <container>
  - When <name|container> is omitted, auto-picks only when exactly one workspace exists.
EOF
    return 0
  fi

  local container=''
  container="$(_codex_workspace_resolve_container "$arg1")" || return $?

  local launcher=''
  launcher="$(_codex_workspace_resolve_launcher_for_callthrough)" || return $?

  print -r -- "+ $launcher stop $container"
  "$launcher" stop "$container"
  return $?
}

# agent-workspace <subcommand> [args...]
# Host entrypoint for creating and managing Codex workspace containers.
agent-workspace() {
  emulate -L zsh
  setopt pipe_fail

  local arg1="${1:-}"

  case "$arg1" in
    ""|-h|--help)
      _codex_workspace_usage
      return 0
      ;;
    auth)
      shift 1 2>/dev/null || true
      agent-workspace-auth "$@"
      return $?
      ;;
    ls)
      shift 1 2>/dev/null || true
      agent-workspace-list "$@"
      return $?
      ;;
    start)
      shift 1 2>/dev/null || true
      agent-workspace-start "$@"
      return $?
      ;;
    stop)
      shift 1 2>/dev/null || true
      agent-workspace-stop "$@"
      return $?
      ;;
    list)
      print -u2 -r -- "error: subcommand removed: list"
      print -u2 -r -- "hint: use: agent-workspace ls"
      return 2
      ;;
    create)
      shift 1 2>/dev/null || true
      ;;
    rm)
      shift 1 2>/dev/null || true
      agent-workspace-rm "$@"
      return $?
      ;;
    remove)
      print -u2 -r -- "error: subcommand removed: remove"
      print -u2 -r -- "hint: use: agent-workspace rm"
      return 2
      ;;
    delete)
      print -u2 -r -- "error: subcommand removed: delete"
      print -u2 -r -- "hint: use: agent-workspace rm --all"
      return 2
      ;;
    exec)
      shift 1 2>/dev/null || true
      agent-workspace-exec "$@"
      return $?
      ;;
    rsync)
      shift 1 2>/dev/null || true
      agent-workspace-rsync "$@"
      return $?
      ;;
    reset)
      shift 1 2>/dev/null || true
      agent-workspace-reset "$@"
      return $?
      ;;
    tunnel)
      shift 1 2>/dev/null || true
      agent-workspace-tunnel "$@"
      return $?
      ;;
    *)
      print -u2 -r -- "error: unknown subcommand: $arg1"
      print -u2 -r -- "hint: expected: auth|create|ls|start|stop|rm|exec|rsync|reset|tunnel"
      print -u2 -r -- "hint: agent-workspace create [--private-repo ...] [repo...]"
      _codex_workspace_usage
      return 2
      ;;
  esac

  local -a repos=()
  local private_repo_raw="${AGENT_WORKSPACE_PRIVATE_REPO-}"
  local -i no_extras=0
  local -i no_work_repos=0
  local -i want_help=0
  local workspace_name=''
  local codex_profile="${AGENT_WORKSPACE_AGENT_PROFILE-}"
  local -i want_gpg_import=0
  local gpg_key="${AGENT_WORKSPACE_GPG_KEY-}"

  local gpg_mode="${AGENT_WORKSPACE_GPG:-none}"
  case "$gpg_mode" in
    none|false|"")
      want_gpg_import=0
      ;;
    import|true)
      want_gpg_import=1
      ;;
    *)
      print -u2 -r -- "error: AGENT_WORKSPACE_GPG must be import|none (got: $gpg_mode)"
      return 2
      ;;
  esac

  while (( $# > 0 )); do
    case "$1" in
      -h|--help)
        want_help=1
        shift
        ;;
      --name)
        workspace_name="${2-}"
        shift 2 2>/dev/null || break
        ;;
      --name=*)
        workspace_name="${1#*=}"
        shift
        ;;
      --private-repo)
        private_repo_raw="${2-}"
        shift 2 2>/dev/null || break
        ;;
      --private-repo=*)
        private_repo_raw="${1#*=}"
        shift
        ;;
      --codex-profile)
        codex_profile="${2-}"
        shift 2 2>/dev/null || break
        ;;
      --codex-profile=*)
        codex_profile="${1#*=}"
        shift
        ;;
      --no-extras)
        no_extras=1
        shift
        ;;
      --no-work-repos)
        no_work_repos=1
        shift
        ;;
      --gpg)
        want_gpg_import=1
        shift
        ;;
      --no-gpg)
        want_gpg_import=0
        shift
        ;;
      --gpg-key)
        gpg_key="${2-}"
        want_gpg_import=1
        shift 2 2>/dev/null || true
        ;;
      --gpg-key=*)
        gpg_key="${1#*=}"
        want_gpg_import=1
        shift
        ;;
      --)
        shift
        while (( $# > 0 )); do
          repos+=("$1")
          shift
        done
        ;;
      -*)
        print -u2 -r -- "error: unknown option: $1"
        return 2
        ;;
      *)
        repos+=("$1")
        shift
        ;;
    esac
  done

  if (( want_help )); then
    _codex_workspace_usage
    return 0
  fi

  if [[ -n "${codex_profile//[[:space:]]/}" ]]; then
    if [[ "$codex_profile" == *'/'* || "$codex_profile" == *'..'* || "$codex_profile" == *[[:space:]]* ]]; then
      print -u2 -r -- "error: invalid codex profile name: $codex_profile"
      return 2
    fi
    if [[ ! -d "$HOME/.config/AGENT_secrets" ]]; then
      print -u2 -r -- "error: codex secrets dir not found: $HOME/.config/AGENT_secrets"
      print -u2 -r -- "hint: unset AGENT_WORKSPACE_AGENT_PROFILE or create secrets dir"
      return 1
    fi
  else
    codex_profile=''
  fi

  local -a codex_profile_arg=()
  if [[ -n "$codex_profile" ]]; then
    codex_profile_arg=(--codex-profile "$codex_profile")
  fi

  if (( no_work_repos )); then
    if (( ${#repos[@]} > 0 )); then
      print -u2 -r -- "error: --no-work-repos does not accept repo args"
      print -u2 -r -- "got: ${(j: :)repos}"
      return 2
    fi
    if [[ -z "${workspace_name//[[:space:]]/}" ]]; then
      print -u2 -r -- "error: --no-work-repos requires --name <name>"
      return 2
    fi
  else
    if (( ${#repos[@]} == 0 )); then
      local detected_repo=''
      detected_repo="$(_codex_workspace_repo_default_from_cwd 2>/dev/null || true)"
      if [[ -z "$detected_repo" ]]; then
        _codex_workspace_usage
        return 0
      fi
      repos=("$detected_repo")
    fi
  fi

  local repo=''
  if (( no_work_repos == 0 )); then
    repo="${repos[1]-}"
  fi

  local launcher="${AGENT_WORKSPACE_LAUNCHER-}"
  local -i launcher_explicit=0
  if [[ -n "${launcher//[[:space:]]/}" ]]; then
    launcher_explicit=1
  else
    launcher="$(_codex_workspace_launcher_default_path)"
  fi
  launcher="$(_codex_workspace_ensure_launcher "$launcher" "$launcher_explicit")" || {
    if (( launcher_explicit )); then
      return 1
    fi
    print -u2 -r -- "hint: set AGENT_WORKSPACE_LAUNCHER to a local launcher path"
    print -u2 -r -- "hint: or set AGENT_WORKSPACE_LAUNCHER_URL to override the download URL"
    return 1
  }

  if (( no_work_repos )); then
    local launcher_help=''
    launcher_help="$("$launcher" --help 2>/dev/null || true)"
    if [[ "$launcher_help" != *"--no-clone"* ]]; then
      print -u2 -r -- "error: launcher does not support --no-clone (required by --no-work-repos)"
      print -u2 -r -- "hint: update the launcher script or set AGENT_WORKSPACE_LAUNCHER to a newer version"
      return 1
    fi
  fi

  if ! command -v docker >/dev/null 2>&1; then
    print -u2 -r -- "error: docker not found on host"
    return 1
  fi

  if ! docker info >/dev/null 2>&1; then
    print -u2 -r -- "error: docker daemon not running (start OrbStack/Docker Desktop)"
    return 1
  fi

  # Opinionated defaults:
  # - No host bind-mounts for workspace/config (works with remote Docker hosts),
  #   except codex secrets (local path bind-mount).
  # - Prefer host `gh` keyring auth (works across orgs) when available; else use GH_TOKEN/GITHUB_TOKEN.
  # - Seed host ~/.config by copying (snapshot), excluding agent-kit + zsh.
  local gh_host="github.com"
  local gh_owner_repo=''
  if (( no_work_repos )); then
    if [[ -n "${private_repo_raw//[[:space:]]/}" ]]; then
      local private_repo_input="${private_repo_raw//[[:space:]]/}"
      if _codex_workspace_parse_repo_spec "$private_repo_input" "$gh_host"; then
        gh_host="${reply[1]-$gh_host}"
        gh_owner_repo="${reply[4]-}"
      fi
    fi
  else
    gh_owner_repo="$repo"
    if [[ "$repo" == http://* || "$repo" == https://* ]]; then
      local without_scheme="${repo#*://}"
      gh_host="${without_scheme%%/*}"
      gh_owner_repo="${without_scheme#*/}"
    elif [[ "$repo" == git@*:* ]]; then
      local without_user="${repo#git@}"
      gh_host="${without_user%%:*}"
      gh_owner_repo="${repo#*:}"
    elif [[ "$repo" == ssh://git@*/* ]]; then
      local without_prefix="${repo#ssh://git@}"
      gh_host="${without_prefix%%/*}"
      gh_owner_repo="${without_prefix#*/}"
    fi
    gh_owner_repo="${gh_owner_repo%.git}"
    gh_owner_repo="${gh_owner_repo%/}"
    if [[ "$gh_owner_repo" == */*/* ]]; then
      local owner="${gh_owner_repo%%/*}"
      local rest="${gh_owner_repo#*/}"
      local name="${rest%%/*}"
      gh_owner_repo="${owner}/${name}"
    fi
  fi

  local auth_mode="${AGENT_WORKSPACE_AUTH:-auto}"
  local env_token="${GH_TOKEN:-${GITHUB_TOKEN:-}}"
  local keyring_token=''
  if command -v gh >/dev/null 2>&1; then
    keyring_token="$(env -u GH_TOKEN -u GITHUB_TOKEN gh auth token -h "$gh_host" 2>/dev/null || true)"
  fi

  local chosen_token=''
  local chosen_source=''
  case "$auth_mode" in
    none)
      chosen_token=""
      chosen_source="none"
      ;;
    env)
      chosen_token="$env_token"
      chosen_source="env"
      ;;
    gh|keyring)
      if [[ -n "$keyring_token" ]]; then
        chosen_token="$keyring_token"
        chosen_source="gh"
      else
        print -u2 -r -- "warn: AGENT_WORKSPACE_AUTH=gh but no gh keyring token found; falling back to GH_TOKEN/GITHUB_TOKEN"
        chosen_token="$env_token"
        chosen_source="env"
      fi
      ;;
    auto|"")
      if [[ -n "$keyring_token" && "$gh_owner_repo" == */* ]]; then
        if GH_TOKEN="$keyring_token" GITHUB_TOKEN="" gh api --hostname "$gh_host" --silent "repos/${gh_owner_repo}" >/dev/null 2>&1; then
          chosen_token="$keyring_token"
          chosen_source="gh"
        else
          chosen_token="$env_token"
          chosen_source="env"
        fi
      elif [[ -n "$keyring_token" ]]; then
        chosen_token="$keyring_token"
        chosen_source="gh"
      else
        chosen_token="$env_token"
        chosen_source="env"
      fi
      ;;
    *)
      print -u2 -r -- "error: unknown AGENT_WORKSPACE_AUTH=$auth_mode (expected: auto|gh|env|none)"
      return 2
      ;;
  esac

  if [[ -n "$env_token" && -n "$keyring_token" && "$chosen_source" == "gh" ]]; then
    print -u2 -r -- "auth: using gh keyring token for $gh_host (set AGENT_WORKSPACE_AUTH=env to force GH_TOKEN)"
  fi

  local -i supports_json=0
  if "$launcher" --supports output-json >/dev/null 2>&1; then
    supports_json=1
  else
    local launcher_help=''
    launcher_help="$("$launcher" --help 2>/dev/null || true)"
    if [[ "$launcher_help" == *"--output json"* ]]; then
      supports_json=1
    fi
  fi

  if (( !supports_json )); then
    print -u2 -r -- "error: launcher does not support --output json (required)"
    print -u2 -r -- "hint: update the launcher or point AGENT_WORKSPACE_LAUNCHER to a newer agent-kit checkout"
    return 1
  fi

  local secrets_dir="$HOME/.config/AGENT_secrets"
  local -a secrets_args=()
  if [[ -d "$secrets_dir" ]]; then
    secrets_args=(--secrets-dir "$secrets_dir" --secrets-mount /home/agent/AGENT_secrets)
  fi

  local tmp_json=''
  tmp_json="$(mktemp "${TMPDIR:-/tmp}/agent-workspace.XXXXXX" 2>/dev/null || true)"
  if [[ -z "$tmp_json" ]]; then
    tmp_json="$(mktemp -t agent-workspace.XXXXXX 2>/dev/null || true)"
  fi
  if [[ -z "$tmp_json" ]]; then
    print -u2 -r -- "error: mktemp failed"
    return 1
  fi

  local -a env_prefix=()
  if [[ -n "$chosen_token" ]]; then
    env_prefix=(env GH_TOKEN="$chosen_token" GITHUB_TOKEN="")
  fi

  # Forward launcher human output to stdout (tests expect it), while capturing stdout-only JSON.
  local -i rc=0
	  if (( no_work_repos )); then
	    { "${env_prefix[@]}" "$launcher" create \
	      --no-clone \
	      --name "$workspace_name" \
	      --host "$gh_host" \
	      "${secrets_args[@]}" \
	      "${codex_profile_arg[@]}" \
	      --output json } 3>&1 1>"$tmp_json" 2>&3
	    rc=$?
	  else
	    { "${env_prefix[@]}" "$launcher" create "$repo" \
	      "${secrets_args[@]}" \
	      "${codex_profile_arg[@]}" \
	      --output json } 3>&1 1>"$tmp_json" 2>&3
	    rc=$?
	  fi
  if (( rc != 0 )); then
    rm -f -- "$tmp_json" 2>/dev/null || true
    return $rc
  fi

  local launcher_json=''
  launcher_json="$(cat "$tmp_json" 2>/dev/null || true)"
  rm -f -- "$tmp_json" 2>/dev/null || true

  local repo_dir=''
  repo_dir="$(_codex_workspace_json_get "$launcher_json" path 2>/dev/null || true)"

  local container=''
  container="$(_codex_workspace_json_get "$launcher_json" workspace 2>/dev/null || true)"
  if [[ -z "$container" ]]; then
    print -u2 -r -- "warn: failed to detect workspace container name from launcher JSON output"
    print -u2 -r -- "warn: skipping ~/.config snapshot and ~/.private setup"
  else
    docker exec -u codex "$container" bash -lc '
      if command -v gh >/dev/null 2>&1; then
        host="${1:-github.com}"
        gh config set git_protocol https -h "$host" 2>/dev/null || gh config set git_protocol https 2>/dev/null || true
      fi
    ' -- "$gh_host" >/dev/null 2>&1 || true

    agent-workspace-refresh-opt-repos "$container" --yes || {
      print -u2 -r -- "warn: failed to refresh /opt/agent-kit and /opt/zsh-kit in $container"
    }

    # Snapshot host ~/.config into the container (skip if already done).
    local snapshot_marker="/home/agent/.agents-env/config.snapshot.ok"
    if docker exec -u codex "$container" bash -lc "test -f '$snapshot_marker'" >/dev/null 2>&1; then
      print -r -- "snapshot: ~/.config already copied (remove $snapshot_marker in container to re-copy)"
    else
      if docker exec -u codex "$container" bash -lc 'mkdir -p "$HOME/.config" "$HOME/.agents-env" 2>/dev/null && test -w "$HOME/.config"' >/dev/null 2>&1; then
        print -r -- "+ snapshot ~/.config -> $container:/home/agent/.config (excluding agent-kit, zsh)"

        local -a tar_no_meta=()
        if command tar --no-acls -cf /dev/null -T /dev/null >/dev/null 2>&1; then
          tar_no_meta+=(--no-acls)
        fi
        if command tar --no-fflags -cf /dev/null -T /dev/null >/dev/null 2>&1; then
          tar_no_meta+=(--no-fflags)
        fi
        if command tar --no-xattrs -cf /dev/null -T /dev/null >/dev/null 2>&1; then
          tar_no_meta+=(--no-xattrs)
        fi

        COPYFILE_DISABLE=1 tar -C "$HOME" \
          "${tar_no_meta[@]}" \
          --exclude='.config/agent-kit' \
          --exclude='.config/AGENT_secrets' \
          --exclude='.config/zsh' \
          -cf - .config \
          | docker exec -i -u codex "$container" tar -C /home/agent -xf -
        if (( $? == 0 )); then
          docker exec -u codex "$container" bash -lc "date -u +%Y-%m-%dT%H:%M:%SZ >'$snapshot_marker'" >/dev/null || true
        else
          print -u2 -r -- "warn: failed to snapshot ~/.config into $container"
        fi
      else
        print -u2 -r -- "warn: $container:/home/agent/.config is not writable (maybe created with --config-dir :ro mount)"
        print -u2 -r -- "warn: re-create the workspace to switch to snapshot mode (rm --volumes, then re-run)"
      fi
	    fi

	    # Apply GitHub auth inside the container without persisting GH_TOKEN/GITHUB_TOKEN
	    # as container env. This keeps auth refreshable via `agent-workspace auth github`.
	    if [[ -n "$chosen_token" ]]; then
	      _codex_workspace_auth_github "$container" "$gh_host" || return $?
	    fi
	
	    if (( no_extras == 0 )); then
	      if [[ -n "${private_repo_raw//[[:space:]]/}" ]]; then
	        local private_repo_input="${private_repo_raw//[[:space:]]/}"
        local -a private_parsed=()
        if ! _codex_workspace_parse_repo_spec "$private_repo_input" "$gh_host"; then
          print -u2 -r -- "warn: invalid private repo (expected OWNER/REPO or URL): $private_repo_raw"
        else
          private_parsed=("${reply[@]}")
          local private_owner_repo="${private_parsed[4]-}"
          local private_repo_url="${private_parsed[5]-}"

          # Pull ~/.private from a dedicated repo and wire it into zsh-kit.
          docker exec -u codex "$container" bash -lc '
            set -euo pipefail
            repo_url="${1:?missing repo_url}"
            owner_repo="${2:?missing owner_repo}"
            target="$HOME/.private"

            if [[ -d "$target/.git" ]]; then
              printf "%s\n" "+ pull ${owner_repo} -> ~/.private"
              git -C "$target" pull --ff-only || true
              exit 0
            fi

            if [[ -e "$target" ]]; then
              printf "%s\n" "warn: $target exists but is not a git repo; skipping clone" >&2
              exit 0
            fi

            printf "%s\n" "+ clone ${owner_repo} -> ~/.private"
            GIT_TERMINAL_PROMPT=0 git clone --progress "$repo_url" "$target"
          ' -- "$private_repo_url" "$private_owner_repo" || {
            print -u2 -r -- "warn: failed to setup ~/.private (repo may require auth)"
          }

          # zsh-kit always loads private scripts from $ZDOTDIR/.private (ZDOTDIR=/opt/zsh-kit).
          # Keep the canonical repo checkout at ~/.private, and symlink zsh-kit to it.
          docker exec -u codex "$container" bash -lc '
            set -euo pipefail
            if [[ -L /opt/zsh-kit/.private ]]; then
              exit 0
            fi
            rm -rf /opt/zsh-kit/.private
            ln -s "$HOME/.private" /opt/zsh-kit/.private
          ' >/dev/null || true
        fi
      fi

      local -i i=0
      for (( i = 2; i <= ${#repos[@]}; i++ )); do
        local extra_repo_raw="${repos[i]-}"
        [[ -n "${extra_repo_raw//[[:space:]]/}" ]] || continue

        local -a extra_parsed=()
        if ! _codex_workspace_parse_repo_spec "$extra_repo_raw" "$gh_host"; then
          print -u2 -r -- "warn: invalid repo (expected OWNER/REPO or URL): $extra_repo_raw"
          continue
        fi
        extra_parsed=("${reply[@]}")

        local extra_owner="${extra_parsed[2]-}"
        local extra_name="${extra_parsed[3]-}"
        local extra_owner_repo="${extra_parsed[4]-}"
        local extra_repo_url="${extra_parsed[5]-}"
        local extra_dest="/work/${extra_owner}/${extra_name}"

        docker exec -u codex "$container" bash -lc '
          set -euo pipefail
          repo_url="${1:?missing repo_url}"
          owner_repo="${2:?missing owner_repo}"
          dest="${3:?missing dest}"

          if [[ -d "${dest%/}/.git" ]]; then
            printf "%s\n" "repo already present: $dest"
            exit 0
          fi

          if [[ -e "$dest" ]]; then
            printf "%s\n" "warn: $dest exists but is not a git repo; skipping clone" >&2
            exit 0
          fi

          printf "%s\n" "+ clone ${owner_repo} -> $dest"
          mkdir -p "$(dirname "$dest")"
          GIT_TERMINAL_PROMPT=0 git clone --progress "$repo_url" "$dest"
        ' -- "$extra_repo_url" "$extra_owner_repo" "$extra_dest" || {
          print -u2 -r -- "warn: failed to clone repo: $extra_repo_raw"
        }
      done
    fi
  fi

  if (( want_gpg_import )); then
    if [[ -z "$container" ]]; then
      print -u2 -r -- "warn: --gpg enabled but workspace container name was not detected; skipping gpg import"
    else
      _codex_workspace_auth_gpg "$container" "$gpg_key" || return $?
    fi
  fi

  local open_path=''
  if [[ -n "${repo_dir//[[:space:]]/}" ]]; then
    open_path="${repo_dir%%[[:space:]]#}"
  elif [[ "$repo" == */* ]]; then
    local owner="${repo%%/*}"
    local name="${repo##*/}"
    open_path="/work/${owner}/${name}"
  else
    open_path="/work"
  fi

  print -r --
  print -r -- "Dev Containers:"
  print -r -- "  - Attach: Cmd+Shift+P -> Dev Containers: Attach to Running Container..."
  print -r -- "  - Open:   ${open_path}"

  if [[ -n "$container" && -n "${open_path//[[:space:]]/}" ]]; then
    local docker_context="default"
    docker_context="$(docker context show 2>/dev/null || true)"
    docker_context="${docker_context%%[[:space:]]#}"
    [[ -n "$docker_context" ]] || docker_context="default"

    local authority_json="{\"containerName\":\"/${container}\",\"settings\":{\"context\":\"${docker_context}\"}}"
    local authority_hex=''
    authority_hex="$(_codex_workspace_hex_encode_ascii "$authority_json" 2>/dev/null || true)"

    if [[ -n "$authority_hex" ]]; then
      local folder_uri="vscode-remote://attached-container+${authority_hex}${open_path}"
      local vscode_url="vscode://vscode-remote/attached-container+${authority_hex}${open_path}"
      print -r -- "  - VS Code: code --new-window --folder-uri \"${folder_uri}\""
      print -r -- "  - Link:   ${vscode_url}"

      local open_vscode_enabled="${AGENT_WORKSPACE_OPEN_VSCODE_ENABLED:-}"
      if [[ -z "$open_vscode_enabled" && -n "${AGENT_WORKSPACE_OPEN_VSCODE:-}" ]]; then
        print -u2 -r -- "warn: AGENT_WORKSPACE_OPEN_VSCODE is deprecated; use AGENT_WORKSPACE_OPEN_VSCODE_ENABLED=true|false"
        open_vscode_enabled="true"
      fi
      case "$open_vscode_enabled" in
        ""|false)
          ;;
        true)
          if command -v code >/dev/null 2>&1; then
            code --new-window --folder-uri "${folder_uri}" >/dev/null 2>&1 || true
          else
            print -u2 -r -- "warn: VS Code CLI (code) not found; open the folder URI manually"
          fi
          ;;
        *)
          print -u2 -r -- "error: AGENT_WORKSPACE_OPEN_VSCODE_ENABLED must be true or false (got: $open_vscode_enabled)"
          return 2
          ;;
      esac
    fi
  fi
}

# --- END _features/agent-workspace/workspace-launcher.zsh

if ! typeset -f agent-workspace >/dev/null 2>&1; then
  print -u2 -r -- "‚ùå missing function: agent-workspace"
  exit 1
fi

agent-workspace "$@"
